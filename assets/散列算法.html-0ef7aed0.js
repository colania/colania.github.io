const e=JSON.parse('{"key":"v-6019800d","path":"/posts/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95.html","title":"散列算法","lang":"zh-CN","frontmatter":{"title":"散列算法","date":"2023-03-24T21:19:58.000Z","category":["coding"],"description":"散列 散列（Hash）也称为哈希，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，这个输出值就是散列值。 散列算法 在实际使用中，不同的输入可能会散列成相同的输出，这时也就产生了冲突。 这时候，我们就希望有一些算法可以保证散列表的足够散列程度，降低冲突几率。 散列算法的宗旨就是：构造冲突较低的散列地址，保证散列表中数据的离散度。 除法散列法 散列长度 m, 对于一个小于 m 的数 p 取模，所得结果为散列地址。对 p 的选择很重要，一般取素数或 m f(k) = k % p （p&lt;=m）","head":[["meta",{"property":"og:url","content":"https://newzone.top/posts/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"田野放空"}],["meta",{"property":"og:title","content":"散列算法"}],["meta",{"property":"og:description","content":"散列 散列（Hash）也称为哈希，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，这个输出值就是散列值。 散列算法 在实际使用中，不同的输入可能会散列成相同的输出，这时也就产生了冲突。 这时候，我们就希望有一些算法可以保证散列表的足够散列程度，降低冲突几率。 散列算法的宗旨就是：构造冲突较低的散列地址，保证散列表中数据的离散度。 除法散列法 散列长度 m, 对于一个小于 m 的数 p 取模，所得结果为散列地址。对 p 的选择很重要，一般取素数或 m f(k) = k % p （p&lt;=m）"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-13T06:00:02.000Z"}],["meta",{"property":"article:author","content":"田野"}],["meta",{"property":"article:published_time","content":"2023-03-24T21:19:58.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-13T06:00:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"散列算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-24T21:19:58.000Z\\",\\"dateModified\\":\\"2023-08-13T06:00:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"田野\\",\\"url\\":\\"https://colania.github.io\\"}]}"]]},"headers":[{"level":2,"title":"除法散列法","slug":"除法散列法","link":"#除法散列法","children":[]},{"level":2,"title":"平方散列法（平方取中法）","slug":"平方散列法-平方取中法","link":"#平方散列法-平方取中法","children":[]},{"level":2,"title":"随机数法","slug":"随机数法","link":"#随机数法","children":[]},{"level":2,"title":"斐波那契（Fibonacci）散列法","slug":"斐波那契-fibonacci-散列法","link":"#斐波那契-fibonacci-散列法","children":[{"level":3,"title":"todo","slug":"todo","link":"#todo","children":[]}]}],"git":{"createdTime":1691906014000,"updatedTime":1691906402000,"contributors":[{"name":"colania","email":"465533104@qq.com","commits":2}]},"readingTime":{"minutes":1.86,"words":557},"filePathRelative":"_posts/散列算法.md","localizedDate":"2023年3月24日","excerpt":"<h1> 散列</h1>\\n<p>散列（Hash）也称为哈希，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，这个输出值就是散列值。</p>\\n<h1> 散列算法</h1>\\n<p>在实际使用中，不同的输入可能会散列成相同的输出，这时也就产生了冲突。 这时候，我们就希望有一些算法可以保证散列表的足够散列程度，降低冲突几率。</p>\\n<p>散列算法的宗旨就是：构造冲突较低的散列地址，保证散列表中数据的离散度。</p>\\n<h2> 除法散列法</h2>\\n<p>散列长度 m, 对于一个小于 m 的数 p 取模，所得结果为散列地址。对 p 的选择很重要，一般取素数或 m</p>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\"><pre class=\\"language-text\\"><code>f(k) = k % p （p&lt;=m）\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
