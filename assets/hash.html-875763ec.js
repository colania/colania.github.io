import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as n,e as s}from"./app-3b65558a.js";const t={},i=s(`<h1 id="散列" tabindex="-1"><a class="header-anchor" href="#散列" aria-hidden="true">#</a> 散列</h1><p>散列（Hash）也称为哈希，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，这个输出值就是散列值。</p><h1 id="散列算法" tabindex="-1"><a class="header-anchor" href="#散列算法" aria-hidden="true">#</a> 散列算法</h1><p>在实际使用中，不同的输入可能会散列成相同的输出，这时也就产生了冲突。 这时候，我们就希望有一些算法可以保证散列表的足够散列程度，降低冲突几率。</p><p>散列算法的宗旨就是：构造冲突较低的散列地址，保证散列表中数据的离散度。</p><h2 id="除法散列法" tabindex="-1"><a class="header-anchor" href="#除法散列法" aria-hidden="true">#</a> 除法散列法</h2><p>散列长度 m, 对于一个小于 m 的数 p 取模，所得结果为散列地址。对 p 的选择很重要，一般取素数或 m</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>f(k) = k % p （p&lt;=m）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因为求模数其实是通过一个除法运算得到的，所以叫“除法散列法”</p><h2 id="平方散列法-平方取中法" tabindex="-1"><a class="header-anchor" href="#平方散列法-平方取中法" aria-hidden="true">#</a> 平方散列法（平方取中法）</h2><p>先通过求关键字的平方值扩大相近数的差别，然后根据表长度取中间的几位数作为散列函数值。又因为一个乘积的中间几位数和乘数的每一位都相关，所以由此产生的散列地址较为均匀。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>公式：f(k) = ((k * k) &gt;&gt; X) &lt;&lt; Y
对于常见的32位整数而言，也就是 f(k) = (k * k) &gt;&gt; 28
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="随机数法" tabindex="-1"><a class="header-anchor" href="#随机数法" aria-hidden="true">#</a> 随机数法</h2><p>选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>公式：f(k) = random(k)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="斐波那契-fibonacci-散列法" tabindex="-1"><a class="header-anchor" href="#斐波那契-fibonacci-散列法" aria-hidden="true">#</a> 斐波那契（Fibonacci）散列法</h2><p>当我们查看 ThreadLocal 执行设置元素时，有这么一段计算哈希值的代码；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">HASH_INCREMENT</span> <span class="token operator">=</span> <span class="token number">0x61c88647</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> nextHashCode<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token constant">HASH_INCREMENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ThreadLocal 使用的就是 斐波那契（Fibonacci）散列法 + 开放寻址法存储数据到数组结构中。之所以使用斐波那契数列，是为了让数据更加散列，减少哈希碰撞。具体来自数学公式的计算求值。<br> 公式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>f(k) = ((k * 2654435769) &gt;&gt; X) &lt;&lt; Y
对于常见的32位整数而言，也就是 f(k) = (k * 2654435769) &gt;&gt; 28
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="todo" tabindex="-1"><a class="header-anchor" href="#todo" aria-hidden="true">#</a> todo</h3><p>通过数据对散列程度进行比对</p>`,22),d=[i];function c(r,l){return e(),n("div",null,d)}const u=a(t,[["render",c],["__file","hash.html.vue"]]);export{u as default};
