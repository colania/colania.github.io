<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>基于大语言模型的软件开发方法论 | Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    
    <script src="/js/format.js"></script>
    










  <meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Arden
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/archives/">归档</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/">分类</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/tags/">标签</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/about">关于我</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>
<script src="/js/menu.js"></script>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/">
                            大语言模型
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">
                            软件开发
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                基于大语言模型的软件开发方法论
            
            
        </div>
        <span class="post-date">
            Feb 12, 2026
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <p>在可见的未来，真正高效的团队，不再是“人写代码、工具打辅助”，而是“能用 AI 的尽量用 AI，人只做校正与确认”。在这样的范式下，AI 不再是一次性的生产力插件，而是被系统性地嵌入到整个产研闭环中，从需求、设计到开发、测试、迭代，都有它的身影。我们的目标，就是让 AI 的输出质量从 80 分稳步进化到 95 分，同时让人类的工作量从 20 分下降到 5 分——人类从“苦力型写代码”转向“意图设计与最终裁决”。</p>
<h2 id="一、以文档为基准的产研闭环"><a href="#一、以文档为基准的产研闭环" class="headerlink" title="一、以文档为基准的产研闭环"></a>一、以文档为基准的产研闭环</h2><p>要让 AI 从“好用”变成“可控”，关键是把原本散落的产研流程，用统一的“文档语言”串成闭环：<br><strong>文档（定义）– 代码（实现）– 测试（验证）一一映射。</strong></p>
<p>传统流程里，文档往往只是“参考材料”，真正落地靠口头沟通和个人经验，AI 无从校准，只能凭提示词“猜”。要把“单向输出”变成“双向校准”，必须反过来：</p>
<ul>
<li>一切以结构化文档为准：需求、接口、约束、边界条件，都写成机器和人都能读懂的“法定语言”。</li>
<li>代码必须可追溯到文档：每个模块、每个接口，都能在文档中找到清晰定义。</li>
<li>测试用例由文档推导：不再“想到什么测什么”，而是从需求与接口规范自动生出测试场景。</li>
</ul>
<p>在这样的基础上，就能建立三大闭环，让 AI 不是“写完就走”，而是始终处在被约束、被反馈、被修正的循环中。</p>
<h2 id="二、三大闭环：让-AI-真正“进化”"><a href="#二、三大闭环：让-AI-真正“进化”" class="headerlink" title="二、三大闭环：让 AI 真正“进化”"></a>二、三大闭环：让 AI 真正“进化”</h2><h3 id="1-生成闭环：从需求到低代码组件"><a href="#1-生成闭环：从需求到低代码组件" class="headerlink" title="1. 生成闭环：从需求到低代码组件"></a>1. 生成闭环：从需求到低代码组件</h3><p>第一层是生成闭环：<strong>需求 → 结构化文档 → AI 生成&#x2F;修改低代码组件</strong>。</p>
<p>具体做法是：</p>
<ul>
<li>需求先结构化：不再是长篇大论的 PRD，而是拆成业务场景、实体模型、接口契约、约束条件等，可以被 AI 精确读取的“字段”。</li>
<li>AI 基于文档生成实现：由 AI 直接生成低代码组件、接口骨架、单元测试模板等，人类只做审阅与小范围修订。</li>
<li>所有改动先改文档再改代码：当需求变化时，不直接改代码，而是先更新结构化文档，由 AI 根据差异去调整实现。</li>
</ul>
<p>这样，代码始终是文档的“投影”，AI 按文档执行，人类围绕文档协同，避免了“越改越乱”的历史遗留问题。</p>
<h3 id="2-质量闭环：从代码到自动自修复"><a href="#2-质量闭环：从代码到自动自修复" class="headerlink" title="2. 质量闭环：从代码到自动自修复"></a>2. 质量闭环：从代码到自动自修复</h3><p>第二层是质量闭环：<strong>代码 → 自动测试 → 日志 → AI 自修复</strong>。</p>
<p>有了文档约束，接下来就是让 AI 对自己的产出负责：</p>
<ul>
<li>自动生成与执行测试：根据接口与约束，让 AI 生成单测、集成测试、契约测试，并纳入流水线持续运行。</li>
<li>日志与异常结构化：运行时的错误、边界情况、性能瓶颈，被结构化为可理解的事件流。</li>
<li>AI 参与自修复：AI 对照日志与测试失败信息，定位“违背了哪条文档约束”，给出补丁或重构建议，再由人类做最终确认。</li>
</ul>
<p>过去“发现 bug → 人肉排查 → 手工修复”的模式，会逐渐变成“系统发现异常 → AI 提出修复方案 → 人只做确认与兜底”，人力主要集中在关键路径与高风险变更上。</p>
<h3 id="3-演进闭环：从运行数据到产品决策"><a href="#3-演进闭环：从运行数据到产品决策" class="headerlink" title="3. 演进闭环：从运行数据到产品决策"></a>3. 演进闭环：从运行数据到产品决策</h3><p>第三层是演进闭环：<strong>运行数据 → 指标分析 → AI 优化建议 → 更新文档</strong>。</p>
<p>软件不是一次性交付，而是持续演化：</p>
<ul>
<li>将运行数据与业务指标结构化：转化为对“功能是否达成目标”的量化反馈，而不仅是技术监控。</li>
<li>AI 分析模式与机会：从转化率、留存、使用路径、错误分布中，提出有根据的优化建议。</li>
<li>决策先落在文档：产品、技术与 AI 共同修改“策略模板”和“功能定义”，再由生成闭环和质量闭环自动推动实现与验证。</li>
</ul>
<p>这样，演进就不再是“凭拍脑袋的想法堆需求”，而是围绕指标、策略模板和结构化文档进行理性迭代。</p>
<h2 id="三、解耦：把复杂系统拆成-AI-可控的块"><a href="#三、解耦：把复杂系统拆成-AI-可控的块" class="headerlink" title="三、解耦：把复杂系统拆成 AI 可控的块"></a>三、解耦：把复杂系统拆成 AI 可控的块</h2><p>要让 AI 在系统里安全、高效地工作，必须先把复杂系统“拆开”，做到纵向分层、横向分类。</p>
<h3 id="1-纵向分层：战略-战术-执行"><a href="#1-纵向分层：战略-战术-执行" class="headerlink" title="1. 纵向分层：战略 &#x2F; 战术 &#x2F; 执行"></a>1. 纵向分层：战略 &#x2F; 战术 &#x2F; 执行</h3><ul>
<li><strong>战略层</strong>：定义愿景、业务目标、关键指标，主要由人负责。</li>
<li><strong>战术层</strong>：落地为策略模板、流程编排、规则集合，人与 AI 共同维护。</li>
<li><strong>执行层</strong>：具体代码、脚本、配置和部署，由 AI 主导生成与修改。</li>
</ul>
<p>通过这样的分层，把“意图”和“实现”剥离开来：AI 主要在执行层和部分战术层活动，人类守住战略与关键策略，不让系统在“黑盒演化”。</p>
<h3 id="2-横向分类：低耦合高内聚的子系统"><a href="#2-横向分类：低耦合高内聚的子系统" class="headerlink" title="2. 横向分类：低耦合高内聚的子系统"></a>2. 横向分类：低耦合高内聚的子系统</h3><p>在同一层级中，再按功能&#x2F;职责划分模块：</p>
<ul>
<li>每个模块低耦合高内聚：职责单一，边界清晰。</li>
<li>出错可在单模块内回滚：避免一个改动牵一发动全身。</li>
<li>AI Coding 的作用范围被限制在局部：只允许在特定子系统、特定文件夹内修改，其他模块通过稳定接口协作。</li>
<li>高层只看接口与目标：隐藏内部细节，让人类专注于“要实现什么”，而不是“具体怎么写”。</li>
</ul>
<p>这种解耦，不只是架构优化，更是 AI 可控性的前提。系统拆得越清楚，AI 的操作空间就越安全，回滚成本越低。</p>
<h2 id="四、安全：给-AI-画清红线与护栏"><a href="#四、安全：给-AI-画清红线与护栏" class="headerlink" title="四、安全：给 AI 画清红线与护栏"></a>四、安全：给 AI 画清红线与护栏</h2><p>让 AI 参与生产，不仅要考虑效率，更要正面回答“安全”问题：它能做什么，不能碰什么。</p>
<h3 id="1-抑制幻觉：缩小视野与法定语言"><a href="#1-抑制幻觉：缩小视野与法定语言" class="headerlink" title="1. 抑制幻觉：缩小视野与法定语言"></a>1. 抑制幻觉：缩小视野与法定语言</h3><ul>
<li>缩小 AI 视野：让它只接触“小任务 + 局部文档”，而不是整个代码库和所有上下文。</li>
<li>使用“法定语言”约束：文档、接口规范、审计规则都采用统一的、机器可解析的格式，成为唯一可信信息源。</li>
<li>所有生成都要“对照文档”：凡是偏离法定语言的建议，一律需要人确认或直接驳回。</li>
</ul>
<h3 id="2-构建安全底座：把危险都封装掉"><a href="#2-构建安全底座：把危险都封装掉" class="headerlink" title="2. 构建安全底座：把危险都封装掉"></a>2. 构建安全底座：把危险都封装掉</h3><ul>
<li>明确安全红线：AI 只在功能实现层活动；工程化底座负责权限、审计、部署、密钥管理等高风险工作。</li>
<li>I&#x2F;O 网关与安全 API：对外请求、防注入、防 XSS、敏感操作等都封装为安全 API，AI 只能调用、不能绕过。</li>
<li>统一中间件权限体系：所有请求在中间件层进行强制校验，避免 AI 产生的代码绕过鉴权。</li>
<li>冗余机制：<ul>
<li>结构冗余，向前兼容，避免一次升级导致大面积故障。</li>
<li>数据冗余，支持随时回滚。</li>
<li>文档冗余，让人和机器都能看懂当前系统状态。</li>
</ul>
</li>
</ul>
<p>通过这种“底座兜底 + 上层约束”的方式，AI 可以积极参与实现细节，却不会有权限改变系统的根基。</p>
<h2 id="五、人机协作：从“改代码”到“改意图”"><a href="#五、人机协作：从“改代码”到“改意图”" class="headerlink" title="五、人机协作：从“改代码”到“改意图”"></a>五、人机协作：从“改代码”到“改意图”</h2><p>在这一整套体系中，人和机器真正的关系，不是“谁替代谁”，而是分工重构：</p>
<ul>
<li><p>人的主要工作：</p>
<ul>
<li>设计边界与接口：定义模块之间如何交互、允许 AI 修改到什么程度。</li>
<li>管理跨系统数据交换：确保数据流合法、安全、可追踪。</li>
<li>维护策略模板与规则：决定系统“在什么情况下做什么”。</li>
</ul>
</li>
<li><p>AI 的主要工作：</p>
<ul>
<li>根据结构化文档实现功能、生成测试、分析日志。</li>
<li>在局部模块内自动修复问题、给出优化建议。</li>
<li>按照规则和模板，执行大量重复而精细的实现工作。</li>
</ul>
</li>
</ul>
<p>于是，团队的心智模式也要跟着升级：</p>
<ul>
<li>从“看到 bug 就去改代码”，转变为“先回到意图和文档，看看定义是否合理”。</li>
<li>所有变更先落在结构化文档，再由 AI 负责同步到代码和测试。</li>
<li>评估工作从“看代码量”变成“看闭环质量”：生成是否有依据，质量是否有反馈，演进是否有数据支撑。</li>
</ul>
<p>当这样的体系跑起来之后，AI 不只是一个“帮忙写点代码的工具”，而是嵌入产研全流程的“自动化搭档”。它让重复的实现、验证、修复工作自动化，人则把时间用在更难、更有价值的问题上：想清楚“我们究竟要做什么”，以及“有哪些边界绝不能被突破”。这，才是“能用 AI 的尽量用 AI，人负责校正与确认”的真正落地形态。</p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2025/11/04/%E6%88%98%E7%95%A5%E6%8E%A7%E5%88%B6%E5%8A%9B%E5%92%8C%E7%AD%96%E7%95%A5%E9%80%89%E6%8B%A9/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
