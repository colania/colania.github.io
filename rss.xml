<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://newzone.top/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://newzone.top/rss.xml" rel="self" type="application/rss+xml"/>
    <title>田野放空</title>
    <link>https://newzone.top/</link>
    <description>探索、经历、思考、归纳、自我提升，记录并输出一切能让自己提升的知识。</description>
    <language>zh-CN</language>
    <pubDate>Mon, 21 Aug 2023 06:47:46 GMT</pubDate>
    <lastBuildDate>Mon, 21 Aug 2023 06:47:46 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>工作英语</category>
    <category>行业追踪</category>
    <category>coding</category>
    <category>java</category>
    <category>生活</category>
    <category>工作心得</category>
    <item>
      <title>电话会议</title>
      <link>https://newzone.top/english/work/meetingEnglish.html</link>
      <guid>https://newzone.top/english/work/meetingEnglish.html</guid>
      <source url="https://newzone.top/rss.xml">电话会议</source>
      <description>minutes an official written record of a meeting. someone write or type everything that is discused during the meeting. eg. If you ever miss a meeting ,you can ask for the minutes from the previous meeting.</description>
      <category>工作英语</category>
      <pubDate>Fri, 24 Mar 2023 21:59:43 GMT</pubDate>
      <content:encoded><![CDATA[<h2> minutes</h2>
<blockquote>
<p>an official written record of a meeting.<br>
someone write or type everything that is discused during the meeting.</p>
</blockquote>
<p>eg. If you ever miss a meeting ,you can ask for the minutes from the previous meeting.</p>
]]></content:encoded>
    </item>
    <item>
      <title>AI工具介绍</title>
      <link>https://newzone.top/posts/AI-tools.html</link>
      <guid>https://newzone.top/posts/AI-tools.html</guid>
      <source url="https://newzone.top/rss.xml">AI工具介绍</source>
      <description>AI工具介绍 随着当前网络数据量的爆发，基于大数据的AI，现在越来越智能了。尤其是chatgpt的推出，AI使用越来越广泛。 本文主要介绍当前广泛使用的AI工具。 chatGPT ChatGPT是一种基于Transformer架构的深度学习模型，可以对语言进行建模和生成。它可以处理问答、对话生成、文本生成等多种任务，可以认为是当前最为智能的AI工具。甚至有人将其称为新时代的奠基者，我们将从互联网时代进入AI时代。 当前chatGPT有两种使用方法： 通过官网使用。 通过chatGPT - API 使用</description>
      <category>行业追踪</category>
      <pubDate>Sat, 18 Mar 2023 11:20:09 GMT</pubDate>
      <content:encoded><![CDATA[<h1> AI工具介绍</h1>
<p>随着当前网络数据量的爆发，基于大数据的AI，现在越来越智能了。尤其是chatgpt的推出，AI使用越来越广泛。</p>
<p>本文主要介绍当前广泛使用的AI工具。</p>
<h2> chatGPT</h2>
<p>ChatGPT是一种基于Transformer架构的深度学习模型，可以对语言进行建模和生成。它可以处理问答、对话生成、文本生成等多种任务，可以认为是当前最为智能的AI工具。甚至有人将其称为新时代的奠基者，我们将从互联网时代进入AI时代。</p>
<p>当前chatGPT有两种使用方法：</p>
<ol>
<li>通过<a href="https://chat.openai.com/" target="_blank" rel="noopener noreferrer">官网</a>使用。</li>
<li>通过chatGPT - API 使用</li>
</ol>
<p>每个账号注册好以后，都有18美元的免费体验机会，这个还是相当给力的。</p>
<p>这里就不讲他如何注册了，当前网络上也有很多的注册方法，例如：</p>
<p><a href="https://juejin.cn/post/7198097078005841980" target="_blank" rel="noopener noreferrer">ChatGPT保姆级教程，一分钟学会使用ChatGPT</a></p>
<h3> 使用方法：</h3>
<ol>
<li>
<p>如何更好的使用chatGPT呢，有些人在使用时，可能觉得这个ai好智障，怎么答非所问的。其实你需要给他一个“人设” 。 比如，你需要告诉chatGPT说假设你是一个精研开发多年的JAVA工程师，擅长微服务架构。后续再进行提问时，答案会更加精准。</p>
<p><a href="%5B%5D(https://github.com/colania/awesome-chatgpt-prompts)">已经整理好的chatGPT人设语句</a></p>
<p><a href="https://github.com/colania/awesome-chatgpt-prompts-zh" target="_blank" rel="noopener noreferrer">中文调教指南</a></p>
</li>
<li>
<p>基于chatGPT的比较好用的二次开发工具。</p>
<ol>
<li>
<p><a href="https://github.com/colania/ChatGPT-Telegram-Workers" target="_blank" rel="noopener noreferrer">tg机器人接入chatGPT-API，且不需要提供服务器</a></p>
</li>
<li>
<p><a href="https://github.com/colania/chatgpt-web" target="_blank" rel="noopener noreferrer">用 Express 和 Vue3 搭建的 ChatGPT 演示网页,需要服务器，需要翻墙</a></p>
</li>
</ol>
</li>
</ol>
<h2> 代码</h2>
<p>自从ChatGPT发布以后，各种垂直领域的AI工具也被相继开发出来。作为软件开发，最先接触到的代码编写工具。</p>
<h3> <a href="https://www.cursor.so/" target="_blank" rel="noopener noreferrer">cursor.so</a></h3>
<p>尝试以后还是挺好用的，可以很容易的做一些需求，比如说算法题，还可以指定他的创作语言，哈哈哈哈。（字节大危机）</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230320215027345.png" alt="image-20230320215027345" tabindex="0" loading="lazy"><figcaption>image-20230320215027345</figcaption></figure>
<h3> <a href="https://www.warp.dev/" target="_blank" rel="noopener noreferrer">Warp</a></h3>
<p>warp其实是一个比较新的一个为开发人员打造的Terminal工具。</p>
<p>Warp解决的痛点，是通过减少配置、方便输入，优化输出，增加常用命令行自动提示(通过fig)，方便查看历史记录，可定义流程，等等实现的。（这些官方可以找到，还是挺好用的）</p>
<p>今天发现Warp也接入了chatGPT，每天有100次的体验机会。</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230320215533735.png" alt="image-20230320215533735" tabindex="0" loading="lazy"><figcaption>image-20230320215533735</figcaption></figure>
<h2> 文档</h2>
<h3> <a href="https://www.notion.so/product/ai" target="_blank" rel="noopener noreferrer">NotionAI</a></h3>
<p>Notion AI可以用来写文案、写策划、写表格、写视频脚本、帮忙读论文做总结等，只要涉及到文档相关的事情，他都会有很亮眼的发挥，可惜的是免费体验机会太少了，只有20次。（可以找某宝增加使用机会）</p>
<p>我在写一些文档的时候，很大一部分基础部分都会用他进行生成。</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230320220639491.png" alt="image-20230320220639491" tabindex="0" loading="lazy"><figcaption>image-20230320220639491</figcaption></figure>
<h3> office copilot</h3>
<p>office copilot是我最为期待的一个工具。对外宣传可以<strong>协助用户生成文档、电子邮件、演示文稿和更多内容</strong>，而且演示效果也确实不错。但是现在还没有机会体验到。而且会接入到微软的所有office工具中，未来可期。</p>
<blockquote>
<p>With Copilot, you’re always in control. You decide what to keep, modify or discard. Now, you can be more creative in Word, more analytical in Excel, more expressive in PowerPoint, more productive in Outlook and more collaborative in Teams.</p>
</blockquote>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/2ndary-image-for-March-16_.webp" alt="2ndary-image-for-March-16_" tabindex="0" loading="lazy"><figcaption>2ndary-image-for-March-16_</figcaption></figure>
<h2> 绘画工具(只介绍通过网络提供服务的)</h2>
<p>AI绘画在人工智能领域中大放异彩，现在只要你浏览互联网，基本上都能发现各种AI画画，而且质量越来越高，越来越逼真，有很多创作已经分不清是照片还是AI绘画。</p>
<h3> <a href="https://openai.com/product/dall-e-2" target="_blank" rel="noopener noreferrer">DALL-E 2</a></h3>
<p>「DALL-E 2」，名称合成自超现实主义艺术家“萨尔瓦多·达利(Salvador Dalí)”和《机器人总动员》的英文名“WALL-E”。 也是OPEN-AI的作品之一。</p>
<figure><img src="https://pic2.zhimg.com/v2-360acc4244e461369d92861fc23c60d9_b.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<h3> <a href="https://www.midjourney.com" target="_blank" rel="noopener noreferrer">Midjourney</a></h3>
<p>Midjourney AI是架设在discord上一个AI工具，使用起来也很方便，可以不断的进行优化。生成效果真的不错。</p>
<p>我在使用时会通过chatGPT将我想要绘画的内容以Midjourney 能够识别的词提取关键字，然后再将这些关键词传给Midjourney进行绘画，效果还是不错滴。而且在频道中有很多大佬分享他们的AI创作。</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230320221218533.png" alt="image-20230320221218533" tabindex="0" loading="lazy"><figcaption>image-20230320221218533</figcaption></figure>
<h3> <a href="https://huggingface.co/spaces/stabilityai/stable-diffusion" target="_blank" rel="noopener noreferrer">StableDiffusion</a></h3>
<p>“Stable Diffusion”是开源图像合成模型，这个 AI 作画工具几乎可以模仿任何视觉风格，如果你输入一个描述性短语，图像就会像魔术一样出现在你的屏幕上。 使用这个工具时，最重要的是找到他能够识别的关键词。</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230320221727648.png" alt="image-20230320221727648" tabindex="0" loading="lazy"><figcaption>image-20230320221727648</figcaption></figure>
<h2> 国内的AI工具</h2>
<h3> 文言一心</h3>
<p>虽然百度文言一心的发布会直播让人尬的直抠脚。没有进行现场演示，只敢放录播不敢实际操作，说的难听一点，<a href="https://www.zhihu.com/search?q=%E8%B4%BE%E8%B7%83%E4%BA%AD&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2939535808%7D" target="_blank" rel="noopener noreferrer">贾跃亭</a>如果是PPT造车的，那<a href="https://www.zhihu.com/search?q=%E6%9D%8E%E5%BD%A6%E5%AE%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2939535808%7D" target="_blank" rel="noopener noreferrer">李彦宏</a>就是PPT造了个AIGC的大模型。</p>
<p>在实际体验的时候，确实效果不尽如人意。但是很很明确的是，这个一定是百度自研的，而不是chatGPT套壳软件。在当前世界脱钩的情况下，在AI方面，拥有一款国产自主的工具也是会有很广泛的市场。目前来看，文言一心相比chatGPT来说也就落后一两年，希望能够不断进步，查缺补漏。</p>
<p>有人说发布会没开多久，股民直接就用脚投票了，但是后面几天的连续猛涨，还是能看出来市场很看好他的未来。</p>
]]></content:encoded>
      <enclosure url="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230320215027345.png" type="image/png"/>
    </item>
    <item>
      <title>ConcurrentHashMap 源码分析</title>
      <link>https://newzone.top/posts/ConcurrentHashMap-analyse.html</link>
      <guid>https://newzone.top/posts/ConcurrentHashMap-analyse.html</guid>
      <source url="https://newzone.top/rss.xml">ConcurrentHashMap 源码分析</source>
      <description>ConcurrentHashMap类图 image-20230321163458604 根据类图看出来，ConcurrentHashMap实现了 Map 接口，继承了 AbstractMap 抽象类，所以大多数的方法也都和我们平时用到的HashMap是相同的，HashMap 有的方法，ConcurrentHashMap 几乎都有，所以当我们需要从 HashMap 切换到 ConcurrentHashMap 时，无需关心两者之间的兼容问题。</description>
      <category>coding</category>
      <pubDate>Sat, 18 Mar 2023 11:29:10 GMT</pubDate>
      <content:encoded><![CDATA[<h2> ConcurrentHashMap类图</h2>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230321163458604.png" alt="image-20230321163458604" tabindex="0" loading="lazy"><figcaption>image-20230321163458604</figcaption></figure>
<p>根据类图看出来，ConcurrentHashMap实现了 Map 接口，继承了 AbstractMap 抽象类，所以大多数的方法也都和我们平时用到的HashMap是相同的，HashMap 有的方法，ConcurrentHashMap 几乎都有，所以当我们需要从 HashMap 切换到 ConcurrentHashMap 时，无需关心两者之间的兼容问题。</p>
<h2> <strong>ConcurrentHashMap几个重要概念</strong></h2>
<h3> 重要参数</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 重要结构</h3>
<ol>
<li>Node&lt;K,V&gt;,这是构成每个元素的基本类。</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>TreeNode构造树的节点</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>TreeBin 不保存用户键或值，而是指向 TreeNode 及其根的列表，由TreeBin完成对红黑树的包装。他们还维护一个读写锁。</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 重要锁</h3>
<ol>
<li><strong>Unsafe CAS</strong></li>
</ol>
<p>在ConcurrentHashMap中，随处可见**<strong>等类似的方法。这个算法的基本思想就是不断地去比较当前内存中的变量值与你指定的一个变量值是否相等，如果相等，则接受你指定的修改的值，否则拒绝你的操作。与我们常见的</strong>乐观锁**类似。</p>
<blockquote>
<p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>
<p>synchronized</p>
<p><em>synchronized</em>是Java中的关键字，是一种同步锁.</p>
</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 方法拆解</h2>
<h3> 1. 构造方法</h3>
<p>​	在任何一个构造方法中，都没有对存储Map元素Node的table变量进行初始化。而是在第一次put操作的时候在进行初始化。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. PUT</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. ConcurrentHashMap的扩容详解</h3>
<ul>
<li>在同一个节点的个数超过8个的时候，会调用treeifyBin方法来看看是扩容还是转化为一棵树</li>
<li>同时在每次添加完元素的addCount方法中，也会判断当前数组中的元素是否达到了sizeCtl的量，如果达到了的话，则会进入transfer方法去扩容</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在tryPresize方法中，并没有加锁，允许多个线程进入，如果数组正在扩张，则当前线程也去帮助扩容。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>扩容操作：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>fn&amp;n</code>可以快速把链表中的元素区分成两类，A类是hash值的第X位为0，B类是hash值的第X位为1，并通过<code>lastRun</code>记录最后需要处理的节点，A类和B类节点可以分散到新数组的槽位14和30中，在原数组的槽位中，蓝色节点第X为0，红色节点第X为1，把链表拉平显示如下：</p>
<figure><img src="https://upload-images.jianshu.io/upload_images/2184951-5e60c316353e8a8f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<ol>
<li>
<p>通过遍历链表，记录<code>runBit</code>和<code>lastRun</code>，分别为1和节点6，所以设置<code>hn</code>为节点6，<code>ln</code>为null；</p>
</li>
<li>
<p>重新遍历链表，以<code>lastRun</code>节点为终止条件，根据第X位的值分别构造ln链表和hn链表：</p>
<ol>
<li>ln：</li>
</ol>
<figure><img src="https://upload-images.jianshu.io/upload_images/2184951-00e946e7b274a8af.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="ln链" tabindex="0" loading="lazy"><figcaption>ln链</figcaption></figure>
<ol start="2">
<li>
<p>Hn:</p>
<figure><img src="https://upload-images.jianshu.io/upload_images/2184951-bcc2a0170ec52d9d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
</li>
</ol>
</li>
<li>
<p>通过CAS把ln链表设置到新数组的i位置，hn链表设置到i+n的位置；</p>
</li>
</ol>
<p>如果该槽位是红黑树结构，则构造树节点<code>lo</code>和<code>hi</code>，遍历红黑树中的节点，同样根据<code>hash&amp;n</code><a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener noreferrer">算法</a>，把节点分为两类，分别插入到<code>lo</code>和<code>hi</code>为头的链表中，根据<code>lo</code>和<code>hi</code>链表中的元素个数分别生成<code>ln</code>和<code>hn</code>节点，其中<code>ln</code>节点的生成逻辑如下：</p>
<ol>
<li>如果<code>lo</code>链表的元素个数小于等于<code>UNTREEIFY_THRESHOLD</code>，默认为6，则通过<code>untreeify</code>方法把树节点链表转化成普通节点链表；</li>
<li>否则判断<code>hi</code>链表中的元素个数是否等于0：如果等于0，表示<code>lo</code>链表中包含了所有原始节点，则设置原始红黑树给<code>ln</code>，否则根据<code>lo</code>链表重新构造红黑树。</li>
<li>最后，同样的通过CAS把<code>ln</code>设置到新数组的<code>i</code>位置，<code>hn</code>设置到<code>i+n</code>位置。</li>
</ol>
<p>​</p>
<h3> 4. GET</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230321163458604.png" type="image/png"/>
    </item>
    <item>
      <title>Dubbo-SPI解析</title>
      <link>https://newzone.top/posts/Dubbo-SPI.html</link>
      <guid>https://newzone.top/posts/Dubbo-SPI.html</guid>
      <source url="https://newzone.top/rss.xml">Dubbo-SPI解析</source>
      <description>Dubbo SPI 解析（Java SPI解析）（上） SPI是什么 SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。 image-20230331142758791</description>
      <category>java</category>
      <pubDate>Fri, 31 Mar 2023 13:40:43 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Dubbo SPI 解析（Java SPI解析）（上）</h1>
<h2> SPI是什么</h2>
<p>SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230331142758791.png" alt="image-20230331142758791" tabindex="0" loading="lazy"><figcaption>image-20230331142758791</figcaption></figure>
<p>Java SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制。</p>
<p>系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。<br>
Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。所以SPI的核心思想就是<strong>解耦</strong>。</p>
<h2> 使用场景</h2>
<p>适用于：<strong>调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略</strong></p>
<ul>
<li>数据库驱动JDBC加载不同类型数据库驱动</li>
<li>SL4J 加载不同日志实现</li>
</ul>
<h2> 使用方式</h2>
<ul>
<li>服务的提供者提供了一种接口的实现</li>
<li>在 Classpath 下的<code> META-INF/services/</code> 目录里创建一个以服务接口命名的文件，此文件记录了该 jar 包提供的服务接口的具体实现类</li>
<li>引入服务的应用通过<code>java.util.ServiceLoder</code>动态装载实现模块，它通过扫描<code>META-INF/services</code>目录下的配置文件找到实现类的全限定名，把类加载到JVM</li>
<li>SPI的实现类必须携带一个不带参数的构造方法；</li>
</ul>
<p>下面我们通过一个简单的示例演示下 JDK SPI 的基本使用方式：</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230331142950553.png" alt="image-20230331142950553" tabindex="0" loading="lazy"><figcaption>image-20230331142950553</figcaption></figure>
<p>首先我们需要创建一个 Log 接口，来模拟日志打印的功能：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来提供两个实现—— Logback 和 Log4j，分别代表两个不同日志框架的实现，如下所示：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在项目的 resources/META-INF/services 目录下添加一个名为<code> com.matt.MyLog</code> 的文件，这是 JDK SPI 需要读取的配置文件，具体内容如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230331143206507.png" alt="image-20230331143206507" tabindex="0" loading="lazy"><figcaption>image-20230331143206507</figcaption></figure>
<p>最后创建 main() 方法，其中会加载上述配置文件，创建全部 MyLog 接口实现的实例，并执行其 log() 方法，如下所示：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 原理解析</h2>
<p>通过上述示例，我们可以看到 JDK SPI 的入口方法是 ServiceLoader.load() 方法，接下来我们就对其具体实现进行深入分析。</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/Ciqc1F8o_V6AR93jAABeDIu_Kso211.png" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure>
<p>在 reload() 方法中，首先会清理 providers 缓存（LinkedHashMap 类型的集合），该缓存用来记录 ServiceLoader 创建的实现对象，其中 Key 为实现类的完整类名，Value 为实现类的对象。之后创建 LazyIterator 迭代器，用于读取 SPI 配置文件并实例化实现类对象。</p>
<p>ServiceLoader.reload() 方法的实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在前面的示例中，main() 方法中使用的迭代器底层就是调用了 <code>ServiceLoader.LazyIterator</code> 实现的。Iterator 接口有两个关键方法：<code>hasNext() </code>方法和 <code>next() </code>方法。这里的 LazyIterator 中的next() 方法最终调用的是其 nextService() 方法，hasNext() 方法最终调用的是 <code>hasNextService() </code>方法，调用关系如下图所示：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>来看看<code>LazyIterator.hasNextService()</code>方法，该方法主要是<strong>负责查找 META-INF/services 目录下的 SPI 配置文件</strong>，并进行遍历，大致实现如下所示：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>hasNextService()</code> 方法中完成 SPI 配置文件的解析之后，再来看<code>LazyIterator.nextService()</code>方法，该方法<strong>负责实例化 <code>hasNextService()</code> 方法读取到的实现类</strong>，其中会将实例化的对象放到 providers 集合中缓存起来，核心实现如下所示：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是Java SPI的核心实现。</p>
<h2> Java SPI 在JDBC的应用</h2>
<p>JDK 中只定义了一个 java.sql.Driver 接口，具体的实现是由不同数据库厂商来提供的。这里我们就以 MySQL 提供的 JDBC 实现包为例进行分析。</p>
<p>在 mysql-connector-java-*.jar 包中的 META-INF/services 目录下，有一个 java.sql.Driver 文件中只有一行内容，如下所示：</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230401214849877.png" alt="image-20230401214849877" tabindex="0" loading="lazy"><figcaption>image-20230401214849877</figcaption></figure>
<p>在使用 mysql-connector-java-*.jar 包连接 MySQL 数据库的时候，我们会用到如下语句创建数据库连接：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>DriverManager 是 JDK 提供的数据库驱动管理器</strong>，其中的静态代码块，如下所示：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在调用 getConnection() 方法的时候，DriverManager 类会被 Java 虚拟机加载、解析并触发 static 代码块的执行。</p>
<p>在 loadInitialDrivers() 方法中通过 JDK SPI 扫描 Classpath 下 java.sql.Driver 接口实现类并实例化，核心实现如下所示：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 总结</h2>
<p>使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p>
]]></content:encoded>
      <enclosure url="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230331142758791.png" type="image/png"/>
    </item>
    <item>
      <title>Dubbo时间轮</title>
      <link>https://newzone.top/posts/Dubbo-time-wheel.html</link>
      <guid>https://newzone.top/posts/Dubbo-time-wheel.html</guid>
      <source url="https://newzone.top/rss.xml">Dubbo时间轮</source>
      <description>Dubbo时间轮 时间轮是一种高效的、批量管理定时任务的调度模型。时间轮一般会实现成一个环形结构，类似一个时钟，分为很多槽，一个槽代表一个时间间隔，每个槽使用双向链表存储定时任务；指针周期性地跳动，跳动到一个槽位，就执行该槽位的定时任务。 1.png</description>
      <category>java</category>
      <pubDate>Sun, 02 Apr 2023 21:58:16 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Dubbo时间轮</h1>
<p><strong>时间轮是一种高效的、批量管理定时任务的调度模型</strong>。时间轮一般会实现成一个环形结构，类似一个时钟，分为很多槽，一个槽代表一个时间间隔，每个槽使用双向链表存储定时任务；指针周期性地跳动，跳动到一个槽位，就执行该槽位的定时任务。</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/CgqCHl8yQfKAEM41AAB8fTu5PCY623.png" alt="1.png" tabindex="0" loading="lazy"><figcaption>1.png</figcaption></figure>
<p>需要注意的是，单层时间轮的容量和精度都是有限的，对于精度要求特别高、时间跨度特别大或是海量定时任务需要调度的场景，通常会使用<strong>多级时间轮</strong>以及<strong>持久化存储与时间轮结合</strong>的方案。</p>
<p>那在 Dubbo 中，时间轮的具体实现方式是怎样的呢？Dubbo 的时间轮实现位于 dubbo-common 模块的 <code>org.apache.dubbo.common.timer </code>包中，下面我们就来分析时间轮涉及的核心接口和实现。</p>
<h2> 核心接口</h2>
<h3> TimerTask接口</h3>
<p>在 Dubbo 中，所有的定时任务都要继承 <strong>TimerTask 接口</strong>。TimerTask 接口非常简单，只定义了一个 run() 方法，该方法的入参是一个 Timeout 接口的对象。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Timeout接口</h3>
<p>Timeout 对象与 TimerTask 对象一一对应，两者的关系类似于线程池返回的 Future 对象与提交到线程池中的任务对象之间的关系。通过 Timeout 对象，我们不仅可以查看定时任务的状态，还可以操作定时任务（例如取消关联的定时任务）。</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230402222206190.png" alt="image-20230402222206190" tabindex="0" loading="lazy"><figcaption>image-20230402222206190</figcaption></figure>
<h3> Timer接口</h3>
<p>Timer 接口定义了定时器的基本行为，如下图所示，其核心是 newTimeout() 方法：提交一个定时任务（TimerTask）并返回关联的 Timeout 对象，这有点类似于向线程池提交任务的感觉。</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230402222333395.png" alt="image-20230402222333395" tabindex="0" loading="lazy"><figcaption>image-20230402222333395</figcaption></figure>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230402223154974.png" alt="image-20230402223154974" tabindex="0" loading="lazy"><figcaption>image-20230402223154974</figcaption></figure>
<h2> 接口实现</h2>
<h3> HashedWheelTimeout</h3>
<p>HashedWheelTimeout 是 Timeout 接口的唯一实现，是 HashedWheelTimer 的内部类。HashedWheelTimeout 扮演了两个角色：</p>
<ul>
<li>第一个，时间轮中双向链表的<strong>节点</strong>，即定时任务 TimerTask 在 HashedWheelTimer 中的容器。</li>
<li>第二个，定时任务 TimerTask 提交到 HashedWheelTimer 之后返回的<strong>句柄</strong>（Handle），用于在时间轮外部查看和控制定时任务。</li>
</ul>
<h4> HashedWheelTimeout 中的核心字段如下：</h4>
<blockquote>
<ul>
<li><strong>prev、next（HashedWheelTimeout类型）</strong>，分别对应当前定时任务在链表中的前驱节点和后继节点。</li>
<li><strong>task（TimerTask类型）</strong>，指实际被调度的任务。</li>
<li><strong>deadline（long类型）</strong>，指定时任务执行的时间。这个时间是在创建 HashedWheelTimeout 时指定的，计算公式是：currentTime（创建 HashedWheelTimeout 的时间） + delay（任务延迟时间） - startTime（HashedWheelTimer 的启动时间），时间单位为纳秒。</li>
<li><strong>state（volatile int类型）</strong>，指定时任务当前所处状态，可选的有三个，分别是 INIT（0）、CANCELLED（1）和 EXPIRED（2）。另外，还有一个 STATE_UPDATER 字段（AtomicIntegerFieldUpdater类型）实现 state 状态变更的原子性。</li>
<li><strong>remainingRounds（long类型）</strong>，指当前任务剩余的时钟周期数。时间轮所能表示的时间长度是有限的，在任务到期时间与当前时刻的时间差，超过时间轮单圈能表示的时长，就出现了套圈的情况，需要该字段值表示剩余的时钟周期。</li>
</ul>
</blockquote>
<h4> HashedWheelTimeout 中的核心方法有：</h4>
<blockquote>
<ul>
<li><strong>isCancelled()、isExpired() 、state() 方法，</strong> 主要用于检查当前 HashedWheelTimeout 状态。</li>
<li><strong>cancel() 方法，</strong> 将当前 HashedWheelTimeout 的状态设置为 CANCELLED，并将当前 HashedWheelTimeout 添加到 cancelledTimeouts 队列中等待销毁。</li>
<li><strong>expire() 方法，</strong> 当任务到期时，会调用该方法将当前 HashedWheelTimeout 设置为 EXPIRED 状态，然后调用其中的 TimerTask 的 run() 方法执行定时任务。</li>
<li><strong>remove() 方法，</strong> 将当前 HashedWheelTimeout 从时间轮中删除。</li>
</ul>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> HashedWheelBucket</h3>
<p>HashedWheelBucket 是时间轮中的一个槽，时间轮中的槽实际上就是一个用于缓存和管理双向链表的容器，双向链表中的每一个节点就是一个 HashedWheelTimeout 对象，也就关联了一个 TimerTask 定时任务。</p>
<p>HashedWheelBucket 持有双向链表的首尾两个节点，分别是 head 和 tail 两个字段，再加上每个 HashedWheelTimeout 节点均持有前驱和后继的引用，这样就可以正向或是逆向遍历整个双向链表了。</p>
<blockquote>
<ul>
<li><strong>addTimeout() 方法</strong>：新增 HashedWheelTimeout 到双向链表的尾部。</li>
<li><strong>pollTimeout() 方法</strong>：移除双向链表中的头结点，并将其返回。</li>
<li><strong>remove() 方法</strong>：从双向链表中移除指定的 HashedWheelTimeout 节点。</li>
<li><strong>clearTimeouts() 方法</strong>：循环调用 pollTimeout() 方法处理整个双向链表，并返回所有未超时或者未被取消的任务。</li>
<li><strong>expireTimeouts() 方法</strong>：遍历双向链表中的全部 HashedWheelTimeout 节点。 在处理到期的定时任务时，会通过 remove() 方法取出，并调用其 expire() 方法执行；对于已取消的任务，通过 remove() 方法取出后直接丢弃；对于未到期的任务，会将 remainingRounds 字段（剩余时钟周期数）减一。</li>
</ul>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> HashedWheelTimer</h3>
<p>HashedWheelTimer 是 Timer 接口的实现，它通过时间轮算法实现了一个定时器。</p>
<p>HashedWheelTimer 会根据当前时间轮指针选定对应的槽（HashedWheelBucket），从双向链表的头部开始迭代，对每个定时任务（HashedWheelTimeout）进行计算，属于当前时钟周期则取出运行，不属于则将其剩余的时钟周期数减一操作。</p>
<blockquote>
<ul>
<li><strong>workerState（volatile int类型）</strong>：时间轮当前所处状态，可选值有 init、started、shutdown。同时，有相应的 AtomicIntegerFieldUpdater 实现 workerState 的原子修改。</li>
<li><strong>startTime（long类型）</strong>：当前时间轮的启动时间，提交到该时间轮的定时任务的 deadline 字段值均以该时间戳为起点进行计算。</li>
<li><strong>wheel（HashedWheelBucket[]类型）</strong>：该数组就是时间轮的环形队列，每一个元素都是一个槽。当指定时间轮槽数为 n 时，实际上会取大于且最靠近 n 的 2 的幂次方值。</li>
<li><strong>timeouts、cancelledTimeouts（LinkedBlockingQueue类型）</strong>：timeouts 队列用于缓冲外部提交时间轮中的定时任务，cancelledTimeouts 队列用于暂存取消的定时任务。HashedWheelTimer 会在处理 HashedWheelBucket 的双向链表之前，先处理这两个队列中的数据。</li>
<li><strong>tick（long类型）</strong>：该字段在 HashedWheelTimer$Worker 中，是时间轮的指针，是一个步长为 1 的单调递增计数器。</li>
<li><strong>mask（int类型）</strong>：掩码， mask = wheel.length - 1，执行 ticks &amp; mask 便能定位到对应的时钟槽。</li>
<li><strong>ticksDuration（long类型）</strong>：时间指针每次加 1 所代表的实际时间，单位为纳秒。</li>
<li><strong>pendingTimeouts（AtomicLong类型）</strong>：当前时间轮剩余的定时任务总数。</li>
<li><strong>workerThread（Thread类型）</strong>：时间轮内部真正执行定时任务的线程。</li>
<li><strong>worker（Worker类型）</strong>：真正执行定时任务的逻辑封装这个 Runnable 对象中。</li>
</ul>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间轮对外提供了一个 newTimeout() 接口用于提交定时任务，在定时任务进入到 timeouts 队列之前会先调用 start() 方法启动时间轮，其中会完成下面两个关键步骤：</p>
<ol>
<li>确定时间轮的 startTime 字段；</li>
<li>启动 workerThread 线程，开始执行 worker 任务。</li>
<li>之后根据 startTime 计算该定时任务的 deadline 字段，最后才能将定时任务封装成 HashedWheelTimeout 并添加到 timeouts 队列。</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面我们来分析时间轮指针一次转动的全流程。</p>
<ol>
<li>时间轮指针转动，时间轮周期开始。</li>
<li>清理用户主动取消的定时任务，这些定时任务在用户取消时，会记录到 cancelledTimeouts 队列中。在每次指针转动的时候，时间轮都会清理该队列。</li>
<li>将缓存在 timeouts 队列中的定时任务转移到时间轮中对应的槽中。</li>
<li>根据当前指针定位对应槽，处理该槽位的双向链表中的定时任务。</li>
<li>检测时间轮的状态。如果时间轮处于运行状态，则循环执行上述步骤，不断执行定时任务。如果时间轮处于停止状态，则执行下面的步骤获取到未被执行的定时任务并加入 unprocessedTimeouts 队列：遍历时间轮中每个槽位，并调用 clearTimeouts() 方法；对 timeouts 队列中未被加入槽中循环调用 poll()。</li>
<li>最后再次清理 cancelledTimeouts 队列中用户主动取消的定时任务。</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Dubbo 中如何使用定时任务</h2>
<p>在 Dubbo 中，时间轮并不直接用于周期性操作，而是只向时间轮提交执行单次的定时任务，在上一次任务执行完成的时候，调用 newTimeout() 方法再次提交当前任务，这样就会在下个周期执行该任务。即使在任务执行过程中出现了 GC、I/O 阻塞等情况，导致任务延迟或卡住，也不会有同样的任务源源不断地提交进来，导致任务堆积。</p>
<p>Dubbo 中对时间轮的应用主要体现在如下两个方面：</p>
<ul>
<li><strong>失败重试，</strong> 例如，Provider 向注册中心进行注册失败时的重试操作，或是 Consumer 向注册中心订阅时的失败重试等。</li>
<li><strong>周期性定时任务，</strong> 例如，定期发送心跳请求，请求超时的处理，或是网络连接断开后的重连机制。</li>
</ul>
<h4> 举例： 注册失败，失败重试</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/CgqCHl8yQfKAEM41AAB8fTu5PCY623.png" type="image/png"/>
    </item>
    <item>
      <title>LPL英文流观赛常见词语</title>
      <link>https://newzone.top/posts/LPL-English-words.html</link>
      <guid>https://newzone.top/posts/LPL-English-words.html</guid>
      <source url="https://newzone.top/rss.xml">LPL英文流观赛常见词语</source>
      <description>LPL英文流观赛常见词语 兴趣会让人进步更快，所以最近开始看起了英文流解说的LPL比赛。一开始必然会有很多专业性的词语听不懂，以及游戏解说们的口速都是飞快的。。。 所以看起来还是比较难。但是好在自身能分析游戏战况，能大致清楚当前发生了什么事情。所以了解一些常用词语，以及听懂一些关键词，对于听懂英文流解说还是有很大帮助的。听懂关键词+ 自己对游戏的了解 大致和 解说想表达的意思差不多多少。 分路 top 上路 mid 中路 jug 打野 adc 下路 sup 辅助</description>
      <category>生活</category>
      <pubDate>Wed, 05 Apr 2023 20:05:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> LPL英文流观赛常见词语</h1>
<p>兴趣会让人进步更快，所以最近开始看起了英文流解说的LPL比赛。一开始必然会有很多专业性的词语听不懂，以及游戏解说们的口速都是飞快的。。。 所以看起来还是比较难。但是好在自身能分析游戏战况，能大致清楚当前发生了什么事情。所以了解一些常用词语，以及听懂一些关键词，对于听懂英文流解说还是有很大帮助的。<code>听懂关键词+ 自己对游戏的了解</code>  大致和 解说想表达的意思差不多多少。</p>
<h3> 分路</h3>
<table>
<thead>
<tr>
<th>top</th>
<th>上路</th>
</tr>
</thead>
<tbody>
<tr>
<td>mid</td>
<td>中路</td>
</tr>
<tr>
<td>jug</td>
<td>打野</td>
</tr>
<tr>
<td>adc</td>
<td>下路</td>
</tr>
<tr>
<td>sup</td>
<td>辅助</td>
</tr>
</tbody>
</table>
<h3> 参数</h3>
<table>
<thead>
<tr>
<th>AD</th>
<th>攻击力</th>
</tr>
</thead>
<tbody>
<tr>
<td>AP</td>
<td>法强</td>
</tr>
<tr>
<td>mana</td>
<td>蓝量</td>
</tr>
<tr>
<td>AS</td>
<td>攻速</td>
</tr>
<tr>
<td>MS</td>
<td>一速</td>
</tr>
<tr>
<td>crit (chance)</td>
<td>暴击几率</td>
</tr>
<tr>
<td>crit dmg</td>
<td>暴击伤害</td>
</tr>
<tr>
<td>ar</td>
<td>护甲</td>
</tr>
<tr>
<td>mr</td>
<td>魔抗</td>
</tr>
<tr>
<td>life steal</td>
<td>吸血</td>
</tr>
<tr>
<td>regen</td>
<td>回复</td>
</tr>
<tr>
<td>OP / broken / imba</td>
<td>强势</td>
</tr>
<tr>
<td>item</td>
<td>装备</td>
</tr>
<tr>
<td>base</td>
<td>高地</td>
</tr>
<tr>
<td>base gate</td>
<td>高地们</td>
</tr>
<tr>
<td>nexus</td>
<td>基地</td>
</tr>
<tr>
<td>inhib</td>
<td>水晶</td>
</tr>
<tr>
<td>outer turret</td>
<td>一塔</td>
</tr>
<tr>
<td>inner turret</td>
<td>二塔</td>
</tr>
<tr>
<td>inhib/base turret</td>
<td>高地塔</td>
</tr>
<tr>
<td>nexus turret</td>
<td>门牙塔</td>
</tr>
<tr>
<td>fountain</td>
<td>泉水</td>
</tr>
<tr>
<td>drag/drake/DR</td>
<td>小龙</td>
</tr>
<tr>
<td>herald</td>
<td>先锋</td>
</tr>
<tr>
<td>baron/BR</td>
<td>大龙</td>
</tr>
<tr>
<td>crab</td>
<td>蟹</td>
</tr>
<tr>
<td>frog</td>
<td>蛙</td>
</tr>
<tr>
<td>birds</td>
<td>F6</td>
</tr>
<tr>
<td>krugs</td>
<td>石头人</td>
</tr>
<tr>
<td>wolves</td>
<td>三狼</td>
</tr>
<tr>
<td>passive</td>
<td>被动</td>
</tr>
<tr>
<td>takedown</td>
<td>击杀和助攻</td>
</tr>
<tr>
<td>hybrid dmg</td>
<td>混伤</td>
</tr>
<tr>
<td>true dmg</td>
<td>真伤</td>
</tr>
<tr>
<td>dot dmg</td>
<td>持续伤</td>
</tr>
<tr>
<td>pure dmg</td>
<td>泉水伤害/英雄自我伤害</td>
</tr>
<tr>
<td>projectile</td>
<td>发射体(能被亚索挡住的技能的飞行实体)</td>
</tr>
<tr>
<td>on-hit effect</td>
<td>攻击特效</td>
</tr>
<tr>
<td>OB/spectator</td>
<td>观战</td>
</tr>
<tr>
<td>fury</td>
<td>怒气</td>
</tr>
<tr>
<td>healing</td>
<td>奶</td>
</tr>
<tr>
<td>spell shield</td>
<td>魔法盾</td>
</tr>
<tr>
<td>trap</td>
<td>陷阱(包括盒子)</td>
</tr>
<tr>
<td>stealth</td>
<td>潜行(包括伪装和隐身，受到伤害会有微光，扫描能看到影子)</td>
</tr>
<tr>
<td>camouflaged</td>
<td>伪装的(靠近会被看到，真眼也会看到)</td>
</tr>
<tr>
<td>invisible</td>
<td>隐身</td>
</tr>
<tr>
<td>active skill/spell</td>
<td>主动技能</td>
</tr>
<tr>
<td>AOE spell</td>
<td>范围技能</td>
</tr>
<tr>
<td>skillshot/direction-targeted spell</td>
<td>指向技能(以方向射出去，能空的</td>
</tr>
<tr>
<td>ground-targeted spell</td>
<td>区域技能(如火男W，有范围的技能)</td>
</tr>
<tr>
<td>unit-targeted spell</td>
<td>锁人技能</td>
</tr>
</tbody>
</table>
<h3> 定位</h3>
<table>
<thead>
<tr>
<th>melee</th>
<th>近战</th>
</tr>
</thead>
<tbody>
<tr>
<td>ranged</td>
<td>远程</td>
</tr>
<tr>
<td>bruiser/fighter/off-tank</td>
<td>战士</td>
</tr>
<tr>
<td>juggernaut</td>
<td>重装战士</td>
</tr>
<tr>
<td>tank</td>
<td>坦克</td>
</tr>
<tr>
<td>assassin</td>
<td>刺客</td>
</tr>
<tr>
<td>marksman</td>
<td>射手</td>
</tr>
<tr>
<td>mage</td>
<td>法师</td>
</tr>
<tr>
<td>split-pusher</td>
<td>分推</td>
</tr>
<tr>
<td>go tanky</td>
<td>出肉</td>
</tr>
<tr>
<td>tankiness</td>
<td>坦度</td>
</tr>
<tr>
<td>aatrox OP af (as fuck)</td>
<td>剑魔强的一笔</td>
</tr>
<tr>
<td>QSS is broken</td>
<td>水银细带很强</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3> 节奏</h3>
<table>
<thead>
<tr>
<th>invade</th>
<th>入侵野区</th>
</tr>
</thead>
<tbody>
<tr>
<td>leash red</td>
<td>帮红</td>
</tr>
<tr>
<td>top and bot swap lanes</td>
<td>换线</td>
</tr>
<tr>
<td>freeze lane</td>
<td>控线</td>
</tr>
<tr>
<td>zoning</td>
<td>控线(压出经验区或血线压制)</td>
</tr>
<tr>
<td>push</td>
<td>推线</td>
</tr>
<tr>
<td>push 4 me</td>
<td>帮推</td>
</tr>
<tr>
<td>gank top</td>
<td>抓上</td>
</tr>
<tr>
<td>dive top</td>
<td>越上</td>
</tr>
<tr>
<td>counter gank</td>
<td>反蹲</td>
</tr>
<tr>
<td>pink</td>
<td>真眼</td>
</tr>
<tr>
<td>minions/winions/creeps</td>
<td>小兵</td>
</tr>
<tr>
<td>cs</td>
<td>补刀</td>
</tr>
<tr>
<td>top mia</td>
<td>上路miss</td>
</tr>
<tr>
<td>laning phase</td>
<td>对线期</td>
</tr>
<tr>
<td>stopwatch</td>
<td>秒表</td>
</tr>
<tr>
<td>has zhonya / his zhonya is up / his zhonya's CDed</td>
<td>有中亚</td>
</tr>
<tr>
<td>cleanse</td>
<td>净化</td>
</tr>
<tr>
<td>out of range</td>
<td>射程不够</td>
</tr>
<tr>
<td>feed tower/turret</td>
<td>送塔</td>
</tr>
<tr>
<td>execution spell/skill</td>
<td>斩杀</td>
</tr>
<tr>
<td>escape</td>
<td>跑路</td>
</tr>
<tr>
<td>snowball</td>
<td>滚雪球</td>
</tr>
<tr>
<td>Ivern is fed</td>
<td>很肥</td>
</tr>
<tr>
<td>turtling to late game</td>
<td>苟到后期</td>
</tr>
<tr>
<td>early game</td>
<td>前期</td>
</tr>
<tr>
<td>late game</td>
<td>后期</td>
</tr>
<tr>
<td>warded</td>
<td>有眼</td>
</tr>
<tr>
<td>bait in bush</td>
<td>草丛埋伏</td>
</tr>
<tr>
<td>bait</td>
<td>勾引</td>
</tr>
<tr>
<td>evade</td>
<td>躲技能</td>
</tr>
<tr>
<td>instakill</td>
<td>秒杀</td>
</tr>
<tr>
<td>camp mid</td>
<td>住中路</td>
</tr>
<tr>
<td>backdoor</td>
<td>偷家</td>
</tr>
<tr>
<td>nuke him</td>
<td>秒了</td>
</tr>
<tr>
<td>team fight</td>
<td>团战</td>
</tr>
<tr>
<td>peel 4 nunu</td>
<td>保努努</td>
</tr>
<tr>
<td>pick teemo</td>
<td>选提莫</td>
</tr>
<tr>
<td>counter pick</td>
<td>counter位</td>
</tr>
<tr>
<td>flank</td>
<td>偷屁股</td>
</tr>
<tr>
<td>Overextend</td>
<td>浪被抓</td>
</tr>
<tr>
<td>re-engage</td>
<td>反开团</td>
</tr>
<tr>
<td>dish out damage</td>
<td>灌伤害</td>
</tr>
<tr>
<td>bounce back/ come back</td>
<td>翻盘</td>
</tr>
<tr>
<td>dragon pit</td>
<td>龙坑</td>
</tr>
<tr>
<td>tournament favorite</td>
<td>夺冠热门</td>
</tr>
<tr>
<td>macro</td>
<td>运营</td>
</tr>
<tr>
<td>map awareness</td>
<td>地图）意识</td>
</tr>
<tr>
<td>funneling sb</td>
<td>资源倾斜给某人</td>
</tr>
<tr>
<td>stall</td>
<td>托后期</td>
</tr>
<tr>
<td>sandbag</td>
<td>吊打</td>
</tr>
<tr>
<td>withstand</td>
<td>抗住</td>
</tr>
<tr>
<td>Somebody has been irrelevant the whole game</td>
<td>隐身、没做事情</td>
</tr>
<tr>
<td>somebody got outplayed/outclassed</td>
<td>被秀了</td>
</tr>
<tr>
<td>clear waves</td>
<td>清线</td>
</tr>
<tr>
<td>melt</td>
<td>瞬间融化</td>
</tr>
<tr>
<td>flash against wall</td>
<td>闪现撞墙</td>
</tr>
<tr>
<td>flash in place</td>
<td>原地闪现</td>
</tr>
<tr>
<td>Somebody is playing to his standard/in form</td>
<td>某人正常发挥</td>
</tr>
<tr>
<td>underperform</td>
<td>发挥失常</td>
</tr>
</tbody>
</table>
<h3> 控制</h3>
<table>
<thead>
<tr>
<th>root/snare</th>
<th>定身</th>
</tr>
</thead>
<tbody>
<tr>
<td>stun</td>
<td>眩晕</td>
</tr>
<tr>
<td>knock aside</td>
<td>击开</td>
</tr>
<tr>
<td>knockback</td>
<td>击退</td>
</tr>
<tr>
<td>knockup</td>
<td>击飞</td>
</tr>
<tr>
<td>pull/hook</td>
<td>钩</td>
</tr>
<tr>
<td>blind</td>
<td>致盲</td>
</tr>
<tr>
<td>fear</td>
<td>恐惧</td>
</tr>
<tr>
<td>ground</td>
<td>缚地</td>
</tr>
<tr>
<td>taunt</td>
<td>嘲讽</td>
</tr>
<tr>
<td>stasis</td>
<td>金身</td>
</tr>
</tbody>
</table>
<p><strong>暂时找到这些，后续不断补充。。</strong></p>
]]></content:encoded>
    </item>
    <item>
      <title>MAT(Java堆分析工具)使用方式</title>
      <link>https://newzone.top/posts/MAT.html</link>
      <guid>https://newzone.top/posts/MAT.html</guid>
      <source url="https://newzone.top/rss.xml">MAT(Java堆分析工具)使用方式</source>
      <description>MAT(Java堆分析工具)使用方式 最近在整理笔记，发现之前在分析JAVA内存问题时写的Mat工具文档还是蛮清晰的，现重新整理一下，分享出来。 MAT是个啥 MAT 全称 Eclipse Memory Analysis Tools 是一个分析 Java堆数据的专业工具，可以计算出内存中对象的实例数量、占用空间大小、引用关系等，看看是谁阻止了垃圾收集器的回收工作，从而定位内存泄漏的原因。 什么时候会用到 OutOfMemoryError的时候，触发full gc，但空间却回收不了，引发内存泄露 java服务器系统异常，比如load飙高，io异常，或者线程死锁等，都可能通过分析堆中的内存对象来定位原因</description>
      <category>coding</category>
      <pubDate>Wed, 29 Mar 2023 15:11:29 GMT</pubDate>
      <content:encoded><![CDATA[<h1> MAT(Java堆分析工具)使用方式</h1>
<p>最近在整理笔记，发现之前在分析JAVA内存问题时写的Mat工具文档还是蛮清晰的，现重新整理一下，分享出来。</p>
<h2> MAT是个啥</h2>
<p>MAT 全称 <code>Eclipse Memory Analysis Tools</code> 是一个分析 Java堆数据的专业工具，可以计算出内存中对象的实例数量、占用空间大小、引用关系等，看看是谁阻止了垃圾收集器的回收工作，从而定位内存泄漏的原因。</p>
<h2> 什么时候会用到</h2>
<ul>
<li>OutOfMemoryError的时候，触发full gc，但空间却回收不了，引发内存泄露</li>
<li>java服务器系统异常，比如load飙高，io异常，或者线程死锁等，都可能通过分析堆中的内存对象来定位原因</li>
</ul>
<h2> 怎么安装</h2>
<p><a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener noreferrer">MAT最新下载版本</a></p>
<p><a href="https://www.eclipse.org/mat/previousReleases.php" target="_blank" rel="noopener noreferrer">MAT历史版本</a></p>
<p>比较重要的是MAT的版本是和JAVA版本有关的，如果下载的话，需要考虑是否支持本地的 JAVA 版本 。</p>
<p>我用的是MAC  Intel 版本，所以下载的是 <code>MemoryAnalyzer-1.12.0.20210602-macosx.cocoa.x86_64</code> 。当前最新的 <code>Memory Analyzer 1.14.0 Release</code> 需要Java 17+。</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329152800939.png" alt="image-20230329152800939" tabindex="0" loading="lazy"><figcaption>image-20230329152800939</figcaption></figure>
<h2> 如何使用</h2>
<p>首先，MAT是用来分析JAVA堆数据的专业工具，那如何才能获取到JAVA堆数据呢。</p>
<h3> 分析文件生成方式</h3>
<ol>
<li>自动生成，jvm启动参数里添加下面配置，当发生OutOfMemoryError时，虚拟机会自动dump内存快照</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2">
<li>手动生成，通过执行jdk自带命令</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="3">
<li>Arthas heapdump命令</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下就可以用 MAT打开转换后的.hprof文件</p>
<p><strong><span style="color:red">（！我这里只是介绍使用方式，并不是arthas有问题，这个dump文件只是随手生成的一份）</span></strong></p>
<h3> 使用MAT</h3>
<p>打开后的首页，里面是一些堆的基本概要信息，比如空间大小、类的数量、对象实例数量、类加载器等等</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329153514976.png" alt="image-20230329153514976" tabindex="0" loading="lazy"><figcaption>image-20230329153514976</figcaption></figure>
<h2> MAT功能</h2>
<p>MAT的核心功能有三类：</p>
<ul>
<li>Actions：
<ul>
<li><strong>Histogram 列出每个类所对应的对象个数，以及所占用的内存大小；</strong></li>
<li><strong>Dominator Tree 以占用总内存的百分比的方式来列举出所有的实例对象，注意这个地方是直接列举出的对应的对象而不是类，这个视图是用来发现大内存对象的</strong></li>
<li>Top Consumers：按照类和包分组的方式展示出占用内存最大的一个对象</li>
<li>Duplicate Classes：检测由多个类加载器所加载的类信息（用来查找重复的类）</li>
</ul>
</li>
<li>Reports：
<ul>
<li><strong>Leak Suspects：通过MAT自动分析当前内存泄露的主要原因</strong></li>
<li>Top Components：Top组件，列出大于总堆1%的组件的报告</li>
</ul>
</li>
<li>Step By Step：
<ul>
<li>Component Report：组件报告,分析属于公共根包或类加载器的对象；</li>
</ul>
</li>
</ul>
<p>下面列举一些会用到的功能。</p>
<h3> Histogram</h3>
<p>列出每个类所对应的对象个数，以及所占用的内存大小。</p>
<p>选中一个ClassName单击后，通过左上角Inspector可以看到当前类的回收情况，内存地址，等</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329154124926.png" alt="image-20230329154124926" tabindex="0" loading="lazy"><figcaption>image-20230329154124926</figcaption></figure>
<h3> Dominator Tree</h3>
<p>以占用总内存的百分比的方式来列举出所有的实例对象，注意这个地方是直接列举出的对应的对象而不是类，这个视图是用来发现大内存对象的</p>
<ul>
<li>
<p>通过<code>Dominator Tree</code> 可以轻松看到那些对象占据了大量堆空间，也就可以断定，当前问题出自于哪个对象。</p>
</li>
<li>
<p>再根据该对象的生成方式，去判断出问题的代码在哪里。</p>
</li>
</ul>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329154234980.png" alt="image-20230329154234980" tabindex="0" loading="lazy"><figcaption>image-20230329154234980</figcaption></figure>
<p>由上图可看到<code>com.taobao.arthas.core.server.ArthasBootstrap @ 0x7ba601258</code>占用了32.97%的内存</p>
<p><strong>那么当我们需要查看，当前该ArthasBootstrap @ 0x7ba601258对象都引用了那些数据，以及当前该对象是被那几个对象所引用的，如何查看？</strong></p>
<p>在当前所要查看的对象右键，点击List Objects可以看到分别提供了：<code>with outgoing references（查看当前该对象的所有的引用信息）</code> 和 <code>with incoming references（查看当前该对象是被那几个对象所引用的）</code> ；</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329154846899.png" alt="image-20230329154846899" tabindex="0" loading="lazy"><figcaption>image-20230329154846899</figcaption></figure>
<p>快速找出某个实例没被释放的原因，可以右健 Path to GC Roots–&gt;exclude all phantom/weak/soft etc. references</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329155941552.png" alt="image-20230329155941552" tabindex="0" loading="lazy"><figcaption>image-20230329155941552</figcaption></figure>
<h3> Leak Suspects</h3>
<p>通过MAT自动分析当前内存问题的主要原因</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329154945313.png" alt="image-20230329154945313" tabindex="0" loading="lazy"><figcaption>image-20230329154945313</figcaption></figure>
<p>可以看到，当前给出的主要原因是：<code>**com.taobao.arthas.core.server.ArthasBootstrap**</code> 实例占据<strong>8,392,160 (32.97%)</strong> bytes ， 是由<code> **com.taobao.arthas.agent.ArthasClassloader @ 0x7ba556870**</code>加载的。</p>
<p>还给出了关键字：</p>
<p><strong>Keywords</strong></p>
<ul>
<li>com.taobao.arthas.core.server.ArthasBootstrap</li>
<li>com.taobao.arthas.agent.ArthasClassloader @ 0x7ba556870</li>
<li>com.taobao.arthas.core.shell.term.impl.http.api.HttpApiHandler</li>
</ul>
<p>点击detail的话，会有更详细的内容</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329155356140.png" alt="image-20230329155356140" tabindex="0" loading="lazy"><figcaption>image-20230329155356140</figcaption></figure>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329155424428.png" alt="image-20230329155424428" tabindex="0" loading="lazy"><figcaption>image-20230329155424428</figcaption></figure>
<h3> Thread_Overview</h3>
<p>用来查看当前进程dump时的所有线程的堆栈信息，通过分析下面所对应的堆栈信息，可以很快速的定位到对应的线程所执行的方法等层级关系，以此来定位对应的异常问题；</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329155550728.png" alt="image-20230329155550728" tabindex="0" loading="lazy"><figcaption>image-20230329155550728</figcaption></figure>
<h3> Heap Dump Overview</h3>
<p>查看全局的内存占用信息</p>
<figure><img src="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329155637605.png" alt="image-20230329155637605" tabindex="0" loading="lazy"><figcaption>image-20230329155637605</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://bard-note.oss-cn-hangzhou.aliyuncs.com/img/image-20230329152800939.png" type="image/png"/>
    </item>
    <item>
      <title>chatGPT.md</title>
      <link>https://newzone.top/posts/chatGPT.html</link>
      <guid>https://newzone.top/posts/chatGPT.html</guid>
      <source url="https://newzone.top/rss.xml">chatGPT.md</source>
      <description>chatGPT prompt 工程 什么是 Prompt 工程？ Prompt 工程是创建提示或指导像 ChatGPT 这样的语言模型输出的过程。它允许用户控制模型的输出并生成符合其特定需求的文本。 ChatGPT 是一种先进的语言模型，能够生成类似于人类的文本。它建立在 Transformer 架构上，可以处 理大量数据并生成高质量的文本。 然而，为了从 ChatGPT 中获得最佳结果，重要的是要了解如何正确地提示模型。 提示可以让用户控制 模型的输出并生成相关、准确和高质量的文本。 在使用 ChatGPT 时，了解它的能力和限制非常重要。 该模型能够生成类似于人类的文本，但如果没有适当的指导，它可能无法始终产生期望的输出。 这就是 Prompt 工程的作用，通过提供清晰而具体的指令，您可以引导模型的输出并确保其相关。 Prompt 公式是提示的特定格式，通常由三个主要元素组成：</description>
      <category>行业追踪</category>
      <pubDate>Sun, 04 Jun 2023 23:09:24 GMT</pubDate>
      <content:encoded><![CDATA[<h1> chatGPT prompt 工程</h1>
<p>什么是 Prompt 工程？ Prompt 工程是创建提示或指导像 ChatGPT 这样的语言模型输出的过程。它允许用户控制模型的输出并生成符合其特定需求的文本。 ChatGPT 是一种先进的语言模型，能够生成类似于人类的文本。它建立在 Transformer 架构上，可以处 理大量数据并生成高质量的文本。 然而，为了从 ChatGPT 中获得最佳结果，重要的是要了解如何正确地提示模型。 提示可以让用户控制 模型的输出并生成相关、准确和高质量的文本。 在使用 ChatGPT 时，了解它的能力和限制非常重要。 该模型能够生成类似于人类的文本，但如果没有适当的指导，它可能无法始终产生期望的输出。 这就是 Prompt 工程的作用，通过提供清晰而具体的指令，您可以引导模型的输出并确保其相关。 <strong>Prompt 公式是提示的特定格式，通常由三个主要元素组成：</strong></p>
<ul>
<li>任务：对提示要求模型生成的内容进行清晰而简洁的陈述。</li>
<li>指令：在生成文本时模型应遵循的指令。</li>
<li>角色：模型在生成文本时应扮演的角色。</li>
</ul>
<h2> 指令提示技术</h2>
<p>指令提示技术是通过为模型提供具体指令来引导 ChatGPT 的输出的一种方法。这种技术对于确保输出相 关和高质量非常有用。 要使用指令提示技术，您需要为模型提供清晰简洁的任务，以及具体的指令以供模型遵循。 例如，如果您正在生成客户服务响应，您将提供任务，例如“生成响应客户查询”的指令，例如“响应应该专业且提供准确的信息”。 提示公式：“<strong>按照以下指示生成[任务]：[指令]”</strong></p>
<p><strong>生成客户服务响应：</strong></p>
<ul>
<li>任务：生成响应客户查询</li>
<li>指令：响应应该专业且提供准确的信息</li>
<li>提示公式：“按照以下指示生成专业且准确的客户查询响应：响应应该专业且提供准确的信息。”</li>
</ul>
<p><strong>生成法律文件：</strong></p>
<ul>
<li>任务：生成法律文件</li>
<li>指令：文件应符合相关法律法规</li>
<li>提示公式：“按照以下指示生成符合相关法律法规的法律文件：文件应符合相关法律法规。”</li>
</ul>
<p>使用指令提示技术时，重要的是要记住指令应该清晰具体。这将有助于确保输出相关和高质量。可以将指令提示技术与下一章节中解释的“角色提示”和“种子词提示”相结合，以增强 ChatGPT 的输出。</p>
<h2> 角色提示</h2>
<p>角色提示技术是通过为 ChatGPT 指定一个特定的角色来引导其输出的一种方式。这种技术<strong>对于生成针对特定上下文或受众的文本非常有用</strong>。 要使用角色提示技术，您需要为模型提供一个清晰具体的角色。 例如，如果您正在生成客户服务回复，您可以提供一个角色，如“客户服务代表”。 提示公式：<strong>“作为[角色]生成[任务]”</strong></p>
<p><strong>生成客户服务回复：</strong></p>
<ul>
<li>任务：生成对客户查询的回复</li>
<li>角色：客户服务代表</li>
<li>提示公式：“作为客户服务代表，生成对客户查询的回复。”</li>
</ul>
<p><strong>生成法律文件：</strong></p>
<ul>
<li>任务：生成法律文件</li>
<li>角色：律师</li>
<li>提示公式：“作为律师，生成法律文件。”</li>
</ul>
<p><strong>将角色提示技术与指令提示和种子词提示结合使用可以增强 ChatGPT 的输出。 下面是一个示例，展示了如何将指令提示、角色提示和种子词提示技术结合使用：</strong></p>
<ul>
<li>任务：为新智能手机生成产品描述</li>
<li>指令：描述应该是有信息量的，具有说服力，并突出智能手机的独特功能</li>
<li>角色：市场代表 种子词：“创新的”</li>
<li>提示公式：“作为市场代表，生成一个有信息量的、有说服力的产品描述，突出新智能手机的创新功能。该智能手机具有以下功能[插入您的功能]”</li>
</ul>
<p>在这个示例中，指令提示用于确保产品描述具有信息量和说服力。角色提示用于确保描述是从市场代表的 角度书写的。而种子词提示则用于确保描述侧重于智能手机的创新功能。</p>
<h2> 标准提示</h2>
<p>标准提示是一种简单的方法，通过为模型提供一个特定的任务来引导 ChatGPT 的输出。例如，如果您想 生成一篇新闻文章的摘要，您可以提供一个任务，如“总结这篇新闻文章”。 <strong>提示公式：“生成一个[任务]”</strong></p>
<p>生成新闻文章的摘要：</p>
<ul>
<li>任务：总结这篇新闻文章</li>
<li>提示公式：“生成这篇新闻文章的摘要”</li>
</ul>
<p>生成一篇产品评论：</p>
<ul>
<li>任务：为一款新智能手机撰写评论</li>
<li>提示公式：“生成这款新智能手机的评论”</li>
</ul>
<p>将标准提示、角色提示和种子词提示技术结合使用的示例：</p>
<p>任务：为一台新笔记本电脑撰写产品评论</p>
<ul>
<li>说明：评论应客观、信息丰富，强调笔记本电脑的独特特点</li>
<li>角色：技术专家</li>
<li>种子词：“强大的”</li>
<li>提示公式：“作为一名技术专家，生成一个客观而且信息丰富的产品评论，强调新笔记本电脑的 强大特点。”</li>
</ul>
<p>在这个示例中，标准提示技术用于确保模型生成产品评论。角色提示用于确保评论是从技术专家的角度写 的。而种子词提示用于确保评论侧重于笔记本电脑的强大特点。</p>
<h2> 零、一和少样本提示</h2>
<p>零样本、一样本和少样本提示是用于从 ChatGPT 生成文本的技术，最少或没有任何示例。当特定任务的数据有限或任务是新的且未定义时，这些技术非常有用。 当任务没有可用的示例时，使用零样本提示技术。模型提供一个通用任务，根据对任务的理解生成文本。 当任务只有一个示例可用时，使用一样本提示技术。模型提供示例，并根据对示例的理解生成文本。 当任务只有有限数量的示例可用时，使用少样本提示技术。模型提供示例，并根据对示例的理解生成文本。 <strong>提示公式：“基于[数量]个示例生成文本”</strong></p>
<p>为没有可用示例的新产品编写产品描述：</p>
<ul>
<li>任务：为新的智能手表编写产品描述</li>
<li>提示公式：“基于零个示例为这款新智能手表生成产品描述”</li>
</ul>
<p>使用一个示例生成产品比较：</p>
<ul>
<li>任务：将新款智能手机与最新的 iPhone 进行比较</li>
<li>提示公式：“使用一个示例（最新的 iPhone）为这款新智能手机生成产品比较”</li>
</ul>
<p>使用少量示例生成产品评论：</p>
<ul>
<li>任务：为新的电子阅读器撰写评论</li>
<li>提示公式：“使用少量示例（3 个其他电子阅读器）为这款新电子阅读器生成评论”</li>
</ul>
<p>这些技术可用于根据模型对任务或提供的示例的理解生成文本。</p>
<h2> “ 让我们思考一下 ” 提示</h2>
<p>“让我们思考一下”提示是一种技巧，可鼓励 ChatGPT 生成反思和思考性的文本。这种技术适用于撰写论文、诗歌或创意写作等任务。 “让我们思考一下”提示的公式非常简单，即“让我们思考一下”后跟一个主题或问题。</p>
<p>生成一篇反思性论文：</p>
<ul>
<li>任务：就个人成长主题写一篇反思性论文</li>
<li>提示公式：“让我们思考一下：个人成长”</li>
</ul>
<p>生成一首诗：</p>
<ul>
<li>任务：写一首关于季节变化的诗</li>
<li>提示公式：“让我们思考一下：季节变化”</li>
</ul>
<p>这个提示要求对特定主题或想法展开对话或讨论。发言者邀请 ChatGPT 参与讨论相关主题。 模型提供了一个提示，作为对话或文本生成的起点。 然后，模型使用其训练数据和算法生成与提示相关的响应。这种技术允许 ChatGPT 根据提供的提示生成 上下文适当且连贯的文本。 要使用“让我们思考一下提示”技术与 ChatGPT，您可以遵循以下步骤：</p>
<ol>
<li>确定您要讨论的主题或想法。</li>
<li>制定一个明确表达主题或想法的提示，并开始对话或文本生成。</li>
<li>用“让我们思考”或“让我们讨论”开头的提示，表明您正在启动对话或讨论。</li>
<li>以下是使用此技术的一些提示示例：</li>
</ol>
<p>提示：“让我们思考气候变化对农业的影响”</p>
<p>提示：“让我们讨论人工智能的当前状态”</p>
<p>提示：“让我们谈谈远程工作的好处和缺点”</p>
<p>您还可以添加开放式问题、陈述或一段您希望模 型继续或扩展的文本。 提供提示后，模型将使用其训练数据和算法生成与提示相关的响应，并以连贯的方式继续对话。 这种独特的提示有助于 ChatGPT 以不同的视角和角度给出答案，从而产生更具动态性和信息性的段落。 使用提示的步骤简单易行，可以真正提高您的写作水平。尝试一下，看看效果如何吧。</p>
<h2> 自洽提示</h2>
<p>自洽提示是一种技术，用于确保 ChatGPT 的输出与提供的输入一致。这种技术对于事实核查、数据验证或文本生成中的一致性检查等任务非常有用。 自洽提示的提示公式是输入文本后跟着指令**“请确保以下文本是自洽的”**。 或者，可以提示模型生成与提供的输入一致的文本。</p>
<p><strong>任务：生成产品评论（文本生成）</strong></p>
<ul>
<li>指令：评论应与输入中提供的产品信息一致</li>
<li>提示公式：“生成与以下产品信息一致的产品评论[插入产品信息]”</li>
</ul>
<p><strong>任务：概括一篇新闻文章（文本摘要）</strong></p>
<ul>
<li>指令：摘要应与文章中提供的信息一致</li>
<li>提示公式：“用与提供的信息一致的方式概括以下新闻文章[插入新闻文章]”</li>
</ul>
<p><strong>任务：完成一个句子（文本完成）</strong></p>
<ul>
<li>指令：完成应与输入中提供的上下文一致</li>
<li>提示公式：“以与提供的上下文一致的方式完成以下句子[插入句子]”</li>
</ul>
<p><strong>任务：检查给定新闻文章的一致性（事实核查）</strong></p>
<ul>
<li>输入文本：“文章中陈述该城市的人口为 500 万，但后来又说该城市的人口为 700 万。”</li>
<li>提示公式：“请确保以下文本是自洽的：文章中陈述该城市的人口为 500 万，但后来又说该城市 的人口为 700 万。”</li>
</ul>
<p><strong>任务：检查给定数据集的一致性（数据验证）</strong></p>
<ul>
<li>输入文本：“数据显示 7 月份的平均温度为 30 度，但最低温度记录为 20 度。”</li>
<li>提示公式：“请确保以下文本是自洽的：数据显示 7 月份的平均温度为 30 度，但最低温度记录 为 20 度。”</li>
</ul>
<h2> 种子词提示</h2>
<p>种子词提示是一种通过提供特定的种子词或短语来控制 ChatGPT 输出的技术。种子词提示的提示公式是 种子词或短语，后跟指令“请根据以下种子词生成文本”。</p>
<p><strong>任务：编写一篇有关龙的故事（文本生成）</strong></p>
<ul>
<li>种子词：“龙”</li>
<li>提示公式：“请根据以下种子词生成文本：龙”</li>
</ul>
<p><strong>任务：将一句话从英语翻译成西班牙语（语言翻译）</strong></p>
<ul>
<li>种子词：“你好”</li>
<li>提示公式：“请根据以下种子词生成文本：你好”</li>
</ul>
<p><strong>种子词提示可以与角色提示和指令提示相结合</strong>，以创建更具体和有针对性的生成文本。通过提供种子词或 短语，模型可以生成与该种子词或短语相关的文本，并通过提供有关期望输出和角色的信息，模型可以以 特定于角色或指令的风格或语气生成文本。这样可以更好地控制生成的文本，并可用于各种应用程序。 以下是提示示例及其公式： 示例 1：文本生成</p>
<p><strong>任务：编写一首诗</strong></p>
<ul>
<li>指令：诗应与种子词“爱”相关，并以十四行诗的形式书写。</li>
<li>角色：诗人</li>
<li>提示公式：“作为诗人，根据以下种子词生成与“爱”相关的十四行诗：”</li>
</ul>
<p><strong>任务：完成一句话</strong></p>
<ul>
<li>指令：完成应与种子词“科学”相关，并以研究论文的形式书写。</li>
<li>角色：研究员</li>
<li>提示公式：“作为研究员，请在与种子词“科学”相关且以研究论文的形式书写的情况下完成以 下句子：[插入句子]”</li>
</ul>
<p><strong>任务：摘要一篇新闻文章（文本摘要）</strong></p>
<ul>
<li>指令：摘要应与种子词“政治”相关，并以中立和公正的语气书写。</li>
<li>角色：记者</li>
<li>提示公式：“作为记者，请以中立和公正的语气摘要以下新闻文章，与种子词“政治”相关： [插入新闻文章]”</li>
</ul>
<h2> 知识生成提示</h2>
<p>知识生成提示是一种从 ChatGPT 中引出新的、原创的信息的技术。 <strong>知识生成提示的公式是“请生成关于 X 的新的和原创的信息”</strong>，其中 X 是感兴趣的主题。 这是一种利用模型预先存在的知识来生成新的信息或回答问题的技术。 要将此提示与 ChatGPT 一起使用，需要将问题或主题作为输入提供给模型，以及指定所生成文本的任务 或目标的提示。 <strong>提示应包括有关所需输出的信息，例如要生成的文本类型以及任何特定的要求或限制。</strong></p>
<p><strong>任务：生成有关特定主题的新信息（生成内容）</strong></p>
<ul>
<li>说明：生成的信息应准确且与主题相关</li>
<li>提示公式：“生成有关[特定主题]的新的准确信息”</li>
</ul>
<p><strong>任务：回答问题（问答）</strong></p>
<ul>
<li>说明：答案应准确且与问题相关</li>
<li>提示公式：“回答以下问题：[插入问题]”</li>
</ul>
<p><strong>任务：将新信息与现有知识整合（知识整合）</strong></p>
<ul>
<li>说明：整合应准确且与主题相关</li>
<li>提示公式：“将以下信息与有关[特定主题]的现有知识整合：[插入新信息]”</li>
</ul>
<p><strong>任务：从给定的数据集中生成有关客户行为的见解（数据分析）</strong></p>
<ul>
<li>提示公式：“请从这个数据集中生成有关客户行为的新的和原创的信息”</li>
</ul>
<h2> 知识整合提示</h2>
<p>这种技术利用模型的现有知识来整合新信息或连接不同的信息片段。 这种技术对于将现有知识与新信息相结合，以生成更全面的特定主题的理解非常有用。</p>
<p>如何与 ChatGPT 一起使用：</p>
<ul>
<li>模型应该提供新信息和现有知识作为输入，以及指定生成文本的任务或目标的提示。</li>
<li>提示应包括有关所需输出的信息，例如要生成的文本类型以及任何特定的要求或限制。</li>
</ul>
<p><strong>任务：将新信息与现有知识整合（知识整合）</strong></p>
<ul>
<li>说明：整合应准确且与主题相关</li>
<li>提示公式：“将以下信息与关于[具体主题]的现有知识整合：[插入新信息]”</li>
</ul>
<p><strong>任务：连接不同的信息片段（连接信息片段）</strong></p>
<ul>
<li>说明：连接应相关且逻辑清晰</li>
<li>提示公式：“以相关且逻辑清晰的方式连接以下信息片段：[插入信息 1] [插入信息 2]”</li>
</ul>
<p><strong>任务：使用新信息更新现有知识（更新现有知识）</strong></p>
<ul>
<li>说明：更新的信息应准确且相关</li>
<li>提示公式：“使用以下信息更新[具体主题]的现有知识：[插入新信息]”</li>
</ul>
<h2> 多项选择提示</h2>
<p>这种技术向模型提供一个问题或任务以及一组预定义的选项作为潜在答案。</p>
<p>该技术对于生成仅限于特定选项集的文本非常有用，可用于问答、文本完成和其他任务。模型可以生成仅 限于预定义选项的文本。</p>
<p>要使用 ChatGPT 的多项选择提示，**需要向模型提供一个问题或任务作为输入，以及一组预定义的选项作 为潜在答案。**提示还应包括有关所需输出的信息，例如要生成的文本类型以及任何特定要求或限制。</p>
<p><strong>任务：回答一个多项选择题（问答）</strong></p>
<ul>
<li>说明：答案应该是预定义的选项之一</li>
<li>提示公式：“通过选择以下选项之一回答以下问题：[插入问题] [插入选项 1] [插入选项 2] [插入选项 3]”</li>
</ul>
<p><strong>任务：使用预定义选项之一完成句子（文本完成）</strong></p>
<ul>
<li>说明：完成应该是预定义的选项之一</li>
<li>提示公式：“通过选择以下选项之一完成以下句子：[插入句子] [插入选项 1] [插入选项 2] [插入选项 3]”</li>
</ul>
<p><strong>任务：将文本分类为积极、中立或消极（情感分析）</strong></p>
<ul>
<li>说明：分类应该是预定义的选项之一</li>
<li>提示公式：“通过选择以下选项之一，将以下文本分类为积极、中立或消极：[插入文本] [积极] [中立] [消极]”</li>
</ul>
<h2> 可解释的软提示</h2>
<p>可解释的软提示是一种技术，可以在提供一定的灵活性的同时控制模型生成的文本。它通过提供一组受控输入和关于所需输出的附加信息来实现。这种技术可以生成更具解释性和可控性的生成文本。</p>
<p><strong>任务：生成一个故事</strong></p>
<ul>
<li>指令：故事应基于一组给定的角色和特定的主题</li>
<li>提示公式：“基于以下角色生成故事：[插入角色]和主题：[插入主题]”</li>
</ul>
<p><strong>任务：完成一句话（文本完成）</strong></p>
<ul>
<li>指令：完成应以特定作者的风格为基础</li>
<li>提示公式：“以[特定作者]的风格完成以下句子：[插入句子]”</li>
</ul>
<p><strong>任务：以特定风格生成文本（语言建模）</strong></p>
<ul>
<li>指令：文本应以特定时期的风格为基础</li>
<li>提示公式：“以[特定时期]的风格生成文本：[插入上下文]”</li>
</ul>
<h2> 控制生成提示</h2>
<p>控制生成提示是一种技术，可让模型在生成文本时对输出进行高度控制。 这可以通过提供一组特定的输入来实现，例如模板、特定词汇或一组约束条件，这些输入可用于指导生成 过程。</p>
<p><strong>任务：生成一个故事</strong></p>
<ul>
<li>说明：该故事应基于特定的模板</li>
<li>提示公式：“根据以下模板生成故事：[插入模板]”</li>
</ul>
<p><strong>任务：完成一句话（文本补全）</strong></p>
<ul>
<li>说明：完成应使用特定的词汇</li>
<li>提示公式：“使用以下词汇完成以下句子：[插入词汇]：[插入句子]”</li>
</ul>
<p><strong>任务：以特定风格生成文本（语言建模）</strong></p>
<ul>
<li>说明：文本应遵循一组特定的语法规则</li>
<li>提示公式：“生成遵循以下语法规则的文本：[插入规则]：[插入上下文]”</li>
</ul>
<p>通过提供一组特定的输入来指导生成过程，控制生成提示使得生成的文本更具可控性和可预测性。</p>
<h2> 问答提示</h2>
<p>问答提示是一种技术，可以让模型生成回答特定问题或任务的文本。<strong>通过将问题或任务与可能与问题或任务相关的任何其他信息一起作为输入提供给模型来实现此目的。</strong></p>
<p><strong>任务：回答一个事实性问题(事实问题回答)</strong></p>
<ul>
<li>说明：答案应准确且相关</li>
<li>提示公式：“回答以下事实问题：[插入问题]”</li>
</ul>
<p><strong>任务：提供一个词的定义</strong></p>
<ul>
<li>提示公式：“定义以下词汇：[插入单词]”</li>
</ul>
<p><strong>任务：从特定来源检索信息</strong></p>
<ul>
<li>提示公式：“从以下来源检索有关[特定主题]的信息：[插入来源]”</li>
</ul>
<h2> 概述提示</h2>
<p>概述提示是一种技术，允许模型在保留其主要思想和信息的同时生成给定文本的较短版本。 这可以通过<strong>将较长的文本作为输入提供给模型并要求其生成该文本的摘要来实现</strong>。 这种技术对于文本概述和信息压缩等任务非常有用。 如何在 ChatGPT 中使用：</p>
<ul>
<li>应该向模型提供较长的文本作为输入，并要求其生成该文本的摘要。</li>
<li>提示还应包括有关所需输出的信息，例如摘要的所需长度和任何特定要求或限制。</li>
</ul>
<p><strong>任务：概述新闻文章</strong></p>
<ul>
<li>说明：摘要应是文章主要观点的简要概述</li>
<li>提示公式：“用一句简短的话概括以下新闻文章：[插入文章]”</li>
</ul>
<p>任务：概括会议记录</p>
<ul>
<li>说明：摘要应突出会议的主要决策和行动</li>
<li>提示公式：“通过列出主要决策和行动来总结以下会议记录：[插入记录]”</li>
</ul>
<p>任务：总结一本书</p>
<ul>
<li>说明：摘要应是书的主要观点的简要概述</li>
<li>提示公式：“用一段简短的段落总结以下书籍：[插入书名]”</li>
</ul>
<h2> 对话提示</h2>
<p>对话提示是一种技术，允许模型生成模拟两个或更多实体之间对话的文本。<strong>通过为模型提供一个上下文和一组角色或实体，以及它们的角色和背景，并要求模型在它们之间生成对话。</strong> 因此，<strong>应为模型提供上下文和一组角色或实体，以及它们的角色和背景。还应向模型提供有关所需输出的 信息，例如对话或交谈的类型以及任何特定的要求或限制。</strong></p>
<p><strong>任务：生成两个角色之间的对话</strong></p>
<ul>
<li>说明：对话应自然且与给定上下文相关</li>
<li>提示公式：“在以下情境中生成以下角色之间的对话[插入角色]”</li>
</ul>
<p><strong>任务：在故事中生成对话</strong></p>
<ul>
<li>说明：对话应与故事的角色和事件一致</li>
<li>提示公式：“在以下故事中生成以下角色之间的对话[插入故事]”</li>
</ul>
<p><strong>任务：为客服聊天机器人生成对话</strong></p>
<ul>
<li>说明：对话应专业且提供准确的信息</li>
<li>提示公式：“在客户询问[插入主题]时，为客服聊天机器人生成专业和准确的对话”</li>
</ul>
<p>因此，这种技术对于对话生成、故事写作和聊天机器人开发等任务非常有用。</p>
<h2> 对抗性提示</h2>
<p>对抗性提示是一种技术，它允许模型生成抵抗某些类型的攻击或偏见的文本。这种技术可用于训练更为稳健和抵抗某些类型攻击或偏见的模型。</p>
<p>要在 ChatGPT 中使用对抗性提示，需要为模型提供一个提示，该提示旨在使模型难以生成符合期望输出 的文本。<strong>提示还应包括有关所需输出的信息，例如要生成的文本类型和任何特定要求或约束</strong>。</p>
<p><strong>任务：生成被分类为特定标签的文本</strong></p>
<ul>
<li>说明：生成的文本应难以分类为特定标签</li>
<li>提示公式：“生成难以分类为[插入标签]的文本”</li>
</ul>
<p>任务：生成难以分类为特定情感的文本</p>
<ul>
<li>说明：生成的文本应难以分类为特定情感</li>
<li>提示公式：“生成难以分类为具有[插入情感]情感的文本”</li>
</ul>
<p>任务：生成难以翻译的文本</p>
<ul>
<li>说明：生成的文本应难以翻译为目标语言</li>
<li>提示公式：“生成难以翻译为[插入目标语言]的文本”</li>
</ul>
<h2> 聚类提示</h2>
<p>聚类提示是一种技术，它可以让模型根据某些特征或特点将相似的数据点分组在一起。</p>
<p>通过提供一组数据点并要求模型根据某些特征或特点将它们分组成簇，可以实现这一目标。</p>
<p>这种技术在数据分析、机器学习和自然语言处理等任务中非常有用。</p>
<p>如何在 ChatGPT 中使用：</p>
<ul>
<li>应该向模型提供一组数据点，并要求它根据某些特征或特点将它们分组成簇。提示还应包括有关所需输出 的信息，例如要生成的簇数和任何特定的要求或约束。</li>
</ul>
<p><strong>任务：将相似的客户评论分组在一起</strong></p>
<ul>
<li>提示公式：“将以下客户评论根据情感分组成簇：[插入评论]”</li>
</ul>
<p><strong>任务：将相似的新闻文章分组在一起</strong></p>
<ul>
<li>提示公式：“将以下新闻文章根据主题分组成簇：[插入文章]”</li>
</ul>
<p><strong>任务：将相似的科学论文分组在一起</strong></p>
<ul>
<li>提示公式：“将以下科学论文根据研究领域分组成簇：[插入论文]”</li>
</ul>
<h2> 强化学习提示</h2>
<p>强化学习提示是一种技术，可以使模型从过去的行动中学习，并随着时间的推移提高其性能。<strong>要在 ChatGPT 中使用强化学习提示，需要为模型提供一组输入和奖励，并允许其根据接收到的奖励调整其行为。提示还应包括有关期望输出的信息，例如要完成的任务以及任何特定要求或限制。这种技术对于决策制定、游戏玩法和自然语言生成等任务非常有用。</strong></p>
<p>任务：生成与特定风格一致的文本</p>
<ul>
<li>提示公式：“使用强化学习来生成与以下风格一致的文本[插入风格]”</li>
</ul>
<p>任务：将文本从一种语言翻译成另一种语言</p>
<ul>
<li>提示公式：“使用强化学习将以下文本[插入文本]从[插入语言]翻译成[插入语言]”</li>
</ul>
<p>任务：回答问题</p>
<ul>
<li>提示公式：“使用强化学习来回答以下问题[插入问题]”</li>
</ul>
<h2> 课程学习提示</h2>
<p>课程学习是一种技术，允许模型通过先训练简单任务，逐渐增加难度来学习复杂任务。 要在 ChatGPT 中使用课程学习提示，<strong>模型应该提供一系列任务，这些任务逐渐增加难度。 提示还应包括有关期望输出的信息，例如要完成的最终任务以及任何特定要求或约束条件。</strong></p>
<p><strong>任务：生成与特定风格一致的文本</strong></p>
<ul>
<li>说明：模型应该在移动到更复杂的风格之前先在简单的风格上进行训练。</li>
<li>提示公式：“使用课程学习来生成与以下风格[插入风格]一致的文本，按照以下顺序[插入顺序]。”</li>
</ul>
<p><strong>任务：将文本从一种语言翻译成另一种语言</strong></p>
<ul>
<li>说明：模型应该在移动到更复杂的语言之前先在简单的语言上进行训练。</li>
<li>提示公式：“使用课程学习将以下语言[插入语言]的文本翻译成以下顺序[插入顺序]。”</li>
</ul>
<p><strong>任务：回答问题</strong></p>
<ul>
<li>说明：模型应该在移动到更复杂的问题之前先在简单的问题上进行训练。</li>
<li>提示公式：“使用课程学习来回答以下问题[插入问题]，按照以下顺序[插入顺序]生成答案。”</li>
</ul>
<h2> 情感分析提示</h2>
<p>情感分析是一种技术，允许模型确定文本的情绪色彩或态度，例如它是积极的、消极的还是中立的。 要在 ChatGPT 中使用情感分析提示，<strong>模型应该提供一段文本并要求根据其情感分类。 提示还应包括关于所需输出的信息，例如要检测的情感类型（例如积极的、消极的、中立的）和任何特定要求或约束条件</strong>。</p>
<p>任务：确定客户评论的情感</p>
<ul>
<li>说明：模型应该将评论分类为积极的、消极的或中立的</li>
<li>提示公式：“对以下客户评论进行情感分析[插入评论]，并将它们分类为积极的、消极的或中立的。”</li>
</ul>
<p>任务：确定推文的情感</p>
<ul>
<li>说明：模型应该将推文分类为积极的、消极的或中立的</li>
<li>提示公式：“对以下推文进行情感分析[插入推文]，并将它们分类为积极的、消极的或中立的。”</li>
</ul>
<p>任务：确定产品评论的情感</p>
<ul>
<li>说明：模型应该将评论分类为积极的、消极的或中立的</li>
<li>提示公式：“对以下产品评论进行情感分析[插入评论]，并将它们分类为积极的、消极的或中立 的。”</li>
</ul>
<h2> 命名实体识别提示</h2>
<p>命名实体识别（NER）是一种技术，它可以使模型识别和分类文本中的命名实体，例如人名、组织机构、 地点和日期等。</p>
<p>要在 ChatGPT 中使用命名实体识别提示，<strong>需要向模型提供一段文本，并要求它识别和分类文本中的命名 实体。</strong></p>
<p>提示还应包括有关所需输出的信息，<strong>例如要识别的命名实体类型（例如人名、组织机构、地点、日期）以 及任何特定要求或约束条件。</strong></p>
<p><strong>任务：在新闻文章中识别和分类命名实体</strong></p>
<ul>
<li>说明：模型应识别和分类人名、组织机构、地点和日期</li>
<li>提示公式：“在以下新闻文章[插入文章]上执行命名实体识别，并识别和分类人名、组织机构、 地点和日期。”</li>
</ul>
<p><strong>任务：在法律文件中识别和分类命名实体</strong></p>
<ul>
<li>说明：模型应识别和分类人名、组织机构、地点和日期</li>
<li>提示公式：“在以下法律文件[插入文件]上执行命名实体识别，并识别和分类人名、组织机构、 地点和日期。”</li>
</ul>
<p><strong>任务：在研究论文中识别和分类命名实体</strong></p>
<ul>
<li>说明：模型应识别和分类人名、组织机构、地点和日期</li>
<li>提示公式：“在以下研究论文[插入论文]上执行命名实体识别，并识别和分类人名、组织机构、 地点和日期。”</li>
</ul>
<h2> 文本分类提示</h2>
<p>文本分类是一种技术，它可以让模型将文本分成不同的类别。这种技术对于自然语言处理、文本分析和情感分析等任务非常有用。</p>
<p>需要注意的是，文本分类和情感分析是不同的。情感分析特别关注于确定文本中表达的情感或情绪。这可能包括确定文本表达了积极、消极还是中性的情感。情感分析通常用于客户评论、社交媒体帖子和其他需 要表达情感的文本。</p>
<p>要在 ChatGPT 中使用文本分类提示，<strong>模型需要提供一段文本，并要求它根据预定义的类别或标签进行分类。提示还应包括有关所需输出的信息，例如类别或标签的数量以及任何特定的要求或约束。</strong></p>
<p>任务：将客户评论分类为不同的类别，例如电子产品、服装和家具</p>
<ul>
<li>说明：模型应根据评论的内容对其进行分类</li>
<li>提示公式：“对以下客户评论 [插入评论] 进行文本分类，并根据其内容将其分类为不同的类 别，例如电子产品、服装和家具。”</li>
</ul>
<p><strong>任务：将新闻文章分类为不同的类别，例如体育、政治和娱乐</strong></p>
<ul>
<li>说明：模型应根据文章的内容对其进行分类</li>
<li>提示公式：“对以下新闻文章 [插入文章] 进行文本分类，并根据其内容将其分类为不同的类 别，例如体育、政治和娱乐。”</li>
</ul>
<p><strong>任务：将电子邮件分类为不同的类别，例如垃圾邮件、重要邮件或紧急邮件</strong></p>
<ul>
<li>说明：模型应根据电子邮件的内容和发件人对其进行分类</li>
<li>提示公式：“对以下电子邮件 [插入电子邮件] 进行文本分类，并根据其内容和发件人将其分类 为不同的类别，例如垃圾邮件、重要邮件或紧急邮件。”</li>
</ul>
<h2> 文本生成提示</h2>
<p>文本生成提示与本书中提到的其他提示技术相关，例如：零、一、几次提示，受控生成提示，翻译提示， 语言建模提示，句子补全提示等。这些提示都与生成文本有关，但它们在生成文本的方式和放置在生成文本上的特定要求或限制方面有所不同。文本生成提示可用于微调预训练模型或训练新模型以执行特定任务。</p>
<p>任务：根据给定的提示生成故事</p>
<ul>
<li>说明：故事应至少包含 1000 个单词，并包括一组特定的角色和情节。</li>
<li>提示公式：“根据以下提示[插入提示]生成一个至少包含 1000 个单词，包括角色[插入角色]和情节[插入情节]的故事。”</li>
</ul>
<p>任务：将给定的文本翻译成另一种语言</p>
<ul>
<li>提示公式：“将以下文本[插入文本]翻译成[插入目标语言]，并确保其准确且符合习惯用语。”</li>
</ul>
<p>任务：完成给定的文本</p>
<ul>
<li>提示公式：“完成以下文本[插入文本]，并确保其连贯一致且符合输入文本。”</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>代码CR模板</title>
      <link>https://newzone.top/posts/code-cr.html</link>
      <guid>https://newzone.top/posts/code-cr.html</guid>
      <source url="https://newzone.top/rss.xml">代码CR模板</source>
      <description>代码CR模板 基础篇 编码风格遵循阿里巴巴Java开发手册 大型复杂流程程序必须提供流程图、时序图 被cr同学在cr开始需简单叙述项目大小及其背景，复杂流程需要cr实现逻辑是否match技术方案，减少实现跟技术方案的gap 业务逻辑划分是否合理,是否耦合 业务逻辑涉及领域的逻辑，明显或耦合的业务逻辑建议拆分 代码编码逻辑是否清晰 被cr同学需要讲清楚主干逻辑 合理有效的注释 逻辑复杂的代码或cr有疑问的逻辑,要求补充合理有效的注释 是否存在冗余代码 多余或者没有引用的代码建议删除 是否存在潜在NPE NPE是日常工作必出现的bug 上下文字段使用不判空，getXX()操作，基本类型拆箱，需要防御式判断或Optional 日志打印规范 强制使用占位符进行日志打印，因为字符串拼接会使用 StringBuilder 的 append() 方式,有一定的性能损耗 logger.info(&amp;quot;are u ok : oid 1&amp;quot;, oid); logger.info(&amp;quot;are u ok : oid 1&amp;quot;, oid); 有没有maven依赖冲突 很多时候诡异的运行时bug，往往由于依赖冲突导致，cr建议确认是否有pom变更 资源释放 无论是网络io还是文件io、资源释放的逻辑需要被cr到 统一错误码 禁止统一返回-1、500等错误码，最好定义枚举，方便追溯问题 异常的处理 出现异常的地方需要确认是否需要进行一下操作：直接返回、抛出异常、重试处理、恢复处理、熔断处理、降级处理、关闭业务</description>
      <category>工作心得</category>
      <pubDate>Sun, 02 Apr 2023 00:34:27 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 代码CR模板</h1>
<h2> 基础篇</h2>
<ol>
<li>
<p>编码风格遵循阿里巴巴Java开发手册</p>
</li>
<li>
<p>大型复杂流程程序必须提供流程图、时序图</p>
<ol>
<li>被cr同学在cr开始需简单叙述项目大小及其背景，复杂流程需要cr实现逻辑是否match技术方案，减少实现跟技术方案的gap</li>
</ol>
</li>
<li>
<p>业务逻辑划分是否合理,是否耦合</p>
<ol>
<li>业务逻辑涉及领域的逻辑，明显或耦合的业务逻辑建议拆分</li>
</ol>
</li>
<li>
<p>代码编码逻辑是否清晰</p>
<ol>
<li>被cr同学需要讲清楚主干逻辑</li>
</ol>
</li>
<li>
<p>合理有效的注释</p>
<ol>
<li>逻辑复杂的代码或cr有疑问的逻辑,要求补充合理有效的注释</li>
</ol>
</li>
<li>
<p>是否存在冗余代码</p>
<ol>
<li>多余或者没有引用的代码建议删除</li>
</ol>
</li>
<li>
<p>是否存在潜在NPE</p>
<ol>
<li>
<blockquote>
<p>NPE是日常工作必出现的bug</p>
<p>上下文字段使用不判空，getXX()操作，基本类型拆箱，需要防御式判断或Optional</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>日志打印规范</p>
<ol>
<li>
<p>强制使用占位符进行日志打印，因为字符串拼接会使用 StringBuilder 的 append() 方式,有一定的性能损耗</p>
<blockquote>
<p><a href="http://logger.info" target="_blank" rel="noopener noreferrer">logger.info</a>("are u ok : oid 1", oid);<br>
<a href="http://logger.info" target="_blank" rel="noopener noreferrer">logger.info</a>("are u ok : oid 1", oid);</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>有没有maven依赖冲突</p>
<ul>
<li>很多时候诡异的运行时bug，往往由于依赖冲突导致，cr建议确认是否有pom变更</li>
</ul>
</li>
<li>
<p>资源释放</p>
<ul>
<li>无论是网络io还是文件io、资源释放的逻辑需要被cr到</li>
</ul>
</li>
<li>
<p>统一错误码</p>
<ul>
<li>禁止统一返回-1、500等错误码，最好定义枚举，方便追溯问题</li>
</ul>
</li>
<li>
<p>异常的处理</p>
<ul>
<li>出现异常的地方需要确认是否需要进行一下操作：直接返回、抛出异常、重试处理、恢复处理、熔断处理、降级处理、关闭业务</li>
</ul>
</li>
</ol>
<h2> 初级篇</h2>
<ol>
<li>数据库索引设计是否合理、是否生效
<ul>
<li>被cr同学要讲清楚设计索引的原因以及效果</li>
</ul>
</li>
<li>代码是否可以使用设计模式或者设计模式是否过度设计
<ul>
<li>if/else 过多或者场景分发类逻辑，建议采用策略模式</li>
<li>不建议小的需求、进行复杂的继承抽象逻辑，良好的设计是模型的合理</li>
<li>不建议引入复杂的框架解决简单问题，有些同学热衷于一个框架搞定所有架构(比如ddd cola)， 毕竟代码的历史性、复杂度框架是评估不了的、好的业务框架脚手架更倾向于用这种思想解决问题，而非照搬</li>
</ul>
</li>
<li>中间件使用是否最佳实践
<ul>
<li>比如mq消费是否正确ack、还是需要重试、还是丢弃</li>
<li>比如redis是否存在大key设计、需要进行合理设计</li>
<li>比如es查询是否设置合理超时时间</li>
</ul>
</li>
<li>线程池使用、参数是否正确、是否业务隔离
<ul>
<li>是否使用公司框架或jdk自带带参线程池构建方法</li>
<li>线程数、队列大小是否配置合理</li>
<li>多业务或调用方、是否配置隔离线程池</li>
</ul>
</li>
<li>如果使用锁，锁范围、粒度是否合适
<ul>
<li>分布式锁的锁区间需要check是否影响其他</li>
</ul>
</li>
<li>事务处理：是否需要事务，事务是否生效
<ul>
<li>持久化操作是否没有加事务</li>
<li>类内部调用是否导致事务没生效</li>
</ul>
</li>
</ol>
<h2> 进阶篇</h2>
<h3> 性能优化</h3>
<ol>
<li>需要缓存的地方是否添加缓存
<ul>
<li>比如依赖的外部接口性能差、添加合适的缓存解决查询问题</li>
</ul>
</li>
<li>乐观锁代替悲观锁</li>
<li>多接口聚合采用多线程加速</li>
</ol>
<h3> 一致性</h3>
<h3> 幂等性</h3>
<ol>
<li>基于状态的幂等
<ul>
<li>基于状态，也就是是说调用该接口，会导致状态变化，如果状态已经发生变化，那么就直接返回<br>
之前的结果即可</li>
</ul>
</li>
<li>基于某个key的幂等
<ul>
<li>通常使用单独的字段来绑定或者日志表来记录，如果存在，直接返回</li>
</ul>
</li>
</ol>
<h3> 重试</h3>
<ol>
<li>接口调用失败重试
<ol>
<li>存在写操作的的外部接口建议不重试、让外部重新发起请求如果需要发起重试、</li>
<li>check提供的接口支持幂等返回</li>
</ol>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>散列算法</title>
      <link>https://newzone.top/posts/hash.html</link>
      <guid>https://newzone.top/posts/hash.html</guid>
      <source url="https://newzone.top/rss.xml">散列算法</source>
      <description>散列 散列（Hash）也称为哈希，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，这个输出值就是散列值。 散列算法 在实际使用中，不同的输入可能会散列成相同的输出，这时也就产生了冲突。 这时候，我们就希望有一些算法可以保证散列表的足够散列程度，降低冲突几率。 散列算法的宗旨就是：构造冲突较低的散列地址，保证散列表中数据的离散度。 除法散列法 散列长度 m, 对于一个小于 m 的数 p 取模，所得结果为散列地址。对 p 的选择很重要，一般取素数或 m f(k) = k % p （p&amp;lt;=m）</description>
      <category>coding</category>
      <pubDate>Fri, 24 Mar 2023 21:19:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 散列</h1>
<p>散列（Hash）也称为哈希，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，这个输出值就是散列值。</p>
<h1> 散列算法</h1>
<p>在实际使用中，不同的输入可能会散列成相同的输出，这时也就产生了冲突。 这时候，我们就希望有一些算法可以保证散列表的足够散列程度，降低冲突几率。</p>
<p>散列算法的宗旨就是：构造冲突较低的散列地址，保证散列表中数据的离散度。</p>
<h2> 除法散列法</h2>
<p>散列长度 m, 对于一个小于 m 的数 p 取模，所得结果为散列地址。对 p 的选择很重要，一般取素数或 m</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因为求模数其实是通过一个除法运算得到的，所以叫“除法散列法”</p>
<h2> 平方散列法（平方取中法）</h2>
<p>先通过求关键字的平方值扩大相近数的差别，然后根据表长度取中间的几位数作为散列函数值。又因为一个乘积的中间几位数和乘数的每一位都相关，所以由此产生的散列地址较为均匀。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 随机数法</h2>
<p>选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 斐波那契（Fibonacci）散列法</h2>
<p>当我们查看 ThreadLocal 执行设置元素时，有这么一段计算哈希值的代码；</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ThreadLocal 使用的就是 斐波那契（Fibonacci）散列法 + 开放寻址法存储数据到数组结构中。之所以使用斐波那契数列，是为了让数据更加散列，减少哈希碰撞。具体来自数学公式的计算求值。<br>
公式：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> todo</h3>
<p>通过数据对散列程度进行比对</p>
]]></content:encoded>
    </item>
  </channel>
</rss>